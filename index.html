<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Study â€” Minimal Prototype</title>
  <style>
    :root {
      --muted: #666;
      --b: #ddd;
      --r: 12px
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 720px;
      margin: 24px auto;
      line-height: 1.45
    }

    h1 {
      font-size: 1.25rem;
      margin-bottom: .25rem
    }

    .muted {
      color: var(--muted);
      font-size: .92rem;
      margin: .25rem 0
    }

    .card {
      border: 1px solid var(--b);
      border-radius: var(--r);
      padding: 16px;
      margin: 16px 0
    }

    .hidden {
      display: none
    }

    textarea {
      width: 100%;
      min-height: 140px;
      font-size: 1rem
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      cursor: pointer
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .row>* {
      flex: 1
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .center {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      border: 1px solid var(--b);
      border-radius: 999px;
      padding: .25rem .6rem .25rem .35rem
    }

    .loader {
      width: 14px;
      height: 14px;
      border: 2px solid #bbb;
      border-top-color: #444;
      border-radius: 50%;
      animation: spin 1s linear infinite
    }

    @keyframes spin {
      to {
        transform: rotate(360deg)
      }
    }

    .linkbox {
      border: 1px dashed var(--b);
      border-radius: 10px;
      padding: 10px;
      margin-top: 8px;
      background: #fafafa
    }

    img.qr {
      width: 140px;
      height: 140px;
      border: 1px solid var(--b);
      border-radius: 8px;
      background: #fff
    }

    .ok {
      color: #137333
    }

    .warn {
      color: #b06000
    }
  </style>
</head>

<body>
  <h1>Typing Study â€” Minimal Prototype</h1>
  <p class="muted">Test your typing speed on both your laptop keyboard and mobile device.</p>

  <section id="s-consent" class="card">
    <h2>Consent</h2>
    <p>This webpage records timing for 3 test sentences per phase(device). No personal info is collected.</p>
    <label class="center" style="gap:.6rem">
      <input id="agree" type="checkbox" /> I am 18â€“22 or 40â€“55 and I consent.
    </label>
    <div class="row" style="margin-top:12px">
      <select id="ageGroup">
        <option value="">Age groupâ€¦</option>
        <option>18â€“22</option>
        <option>40â€“55</option>
      </select>
      <button id="btnStart" disabled>Start</button>
    </div>
    <p id="startInfo" class="mono muted"></p>
  </section>

  <section id="s-handoff" class="card hidden">
    <h2 id="handoffTitle">Start on your other device</h2>
    <p id="handoffMsg" class="muted"></p>
    <div class="linkbox">
      <div class="mono" id="handoffUrl" style="word-break:break-all"></div>
      <div class="center" style="margin-top:8px;justify-content:flex-start">
        <button id="btnCopy">Copy link</button>
        <div class="pill"><span class="loader"></span><span id="waitTxt" class="muted">Waiting for that deviceâ€¦</span>
        </div>
      </div>
    </div>
    <div class="center" style="gap:16px;margin-top:10px">
      <img id="qr" class="qr" alt="QR code" />
      <div class="muted">Scan this QR with your other deviceâ€™s camera.</div>
    </div>
  </section>

  <section id="s-wrong" class="card hidden">
    <h2 class="warn">Use your other device</h2>
    <p id="wrongMsg" class="muted"></p>
    <div class="linkbox">
      <div class="mono" id="wrongUrl" style="word-break:break-all"></div>
    </div>
    <div class="center" style="gap:16px;margin-top:10px">
      <img id="wrongQr" class="qr" alt="QR code" />
      <div class="muted">Open this on your other device, or scan the QR.</div>
    </div>
  </section>

  <section id="s-trial" class="card hidden">
    <h2>Type Exactly What You See</h2>
    <p id="trialHelp" class="muted"></p>
    <p id="phaseLabel" class="muted"></p>
    <p id="sentence" class="mono"></p>
    <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
      placeholder="Type the sentence here. It will submit automatically."></textarea>
    <div class="row" style="margin-top:8px">
      <div class="pill"><span id="spin" class="loader hidden"></span><span id="status" class="muted">Ready</span></div>
      <div id="timer" class="mono" style="text-align:right">0 ms</div>
    </div>
    <p class="muted">Tip: donâ€™t paste; type it out. Backspace is allowed.</p>
  </section>

  <section id="s-done" class="card hidden">
    <h2 class="ok">Done âœ…</h2>
    <p>Thanks! Data sent. Your participant ID:</p>
    <p class="mono" id="pidOut"></p>
    <p class="muted">This page will reset for the next participant automatically.</p>
  </section>

  <script>
    /*** CONFIG ***/
    const ENDPOINT = "https://script.google.com/macros/s/AKfycbz5dTthOWO4crOgte-hUWlIDR4bM2LgLshVOdV-BacKt606Ob8B5dKLxLHB2BalhYG0sg/exec";
    const SECRET = "h33iy43brfu3hf93fhb3fi3ivh3v";
    // Sentences: 1 practice + 3 test sentences (same on both devices)
    const SENTENCES = {
      practice: "The quick brown fox jumps over a sleepy dog in the park.",           // practice
      tests: [
        "Many people find typing on a smartphone harder than on a laptop keyboard.",  // test 1
        "Machine learning can analyze how fast people type under different conditions to improve technology accessibility.", // test 2
        "Data collected from typing tasks can reveal patterns in human performance and guide interface design."              // test 3
      ],
      ids: { practice: "P", tests: ["S1", "S2", "S3"] } // IDs youâ€™ll see in the sheet
    };

    /*** DOM ***/
    const sConsent = document.getElementById("s-consent");
    const sHandoff = document.getElementById("s-handoff");
    const sTrial = document.getElementById("s-trial");
    const sDone = document.getElementById("s-done");
    const agree = document.getElementById("agree");
    const ageGroup = document.getElementById("ageGroup");
    const btnStart = document.getElementById("btnStart");
    const startInfo = document.getElementById("startInfo");
    const handoffMsg = document.getElementById("handoffMsg");
    const handoffUrl = document.getElementById("handoffUrl");
    const btnCopy = document.getElementById("btnCopy");
    const qrImg = document.getElementById("qr");
    const qrWrap = qrImg.parentElement;
    const sentenceEl = document.getElementById("sentence");
    const textarea = document.getElementById("input");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const spinEl = document.getElementById("spin");
    const phaseLabel = document.getElementById("phaseLabel");
    const pidOut = document.getElementById("pidOut");
    const waitTxt = document.getElementById("waitTxt");
    const sWrong = document.getElementById("s-wrong");
    const wrongMsg = document.getElementById("wrongMsg");
    const wrongUrl = document.getElementById("wrongUrl");
    const wrongQr = document.getElementById("wrongQr");
    const trialHelp = document.getElementById("trialHelp");

    /*** STATE ***/
    let pid = null, deviceOrder = null, phase = 1;
    let t0 = 0, lastT = 0, rafId = null, frozen = false;
    let keystrokes = [], backspaces = 0, paused500 = 0, submitting = false;
    let pollId = null;
    // Round control: -1 = practice, then 0,1,2 are test rounds
    let roundIdx = -1;               // start with practice
    const TOTAL_TEST_ROUNDS = 3;     // 3 recorded rounds per phase

    /*** UTIL ***/
    const q = new URLSearchParams(location.search);
    const ms = () => performance.now();
    const show = el => el.classList.remove("hidden");
    const hide = el => el.classList.add("hidden");
    const hideEl = (el) => el.classList.add("hidden");
    const showEl = (el) => el.classList.remove("hidden");
    const setSpin = on => spinEl.classList.toggle("hidden", !on);
    const getDevice = () => /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? "phone" : "laptop";
    const uuid = () => "TS-" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const baseURL = () => location.origin + location.pathname;
    function handoffLink(pid, order, targetPhase) { const u = new URL(baseURL()); u.searchParams.set("pid", pid); u.searchParams.set("order", order); u.searchParams.set("phase", targetPhase); return u.toString(); }
    const qrFor = url => "https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=" + encodeURIComponent(url);
    // put this right after /*** UTIL ***/ (below getDevice)
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const currentDevice = isMobile ? "phone" : "laptop";
    function splitOrder(orderStr) {
      const [firstDev, secondDev] = (orderStr || "").split("â†’");
      return { firstDev, secondDev };
    }


    /*** BACKEND ***/
    async function post(body) {
      const r = await fetch(ENDPOINT, { method: "POST", headers: { "Content-Type": "text/plain" }, body: JSON.stringify({ secret: SECRET, ...body }) });
      return r.json();
    }
    const participantStart = (pid, age) => post({ type: "participant_start", pid, age_group: age, consent_version: "v1", start_iso: new Date().toISOString() });
    const getStatus = (pid) => post({ type: "status", pid });
    const trialSummary = (payload) => post({ type: "trial_summary", ...payload });
    const participantEnd = (pid) => post({ type: "participant_end", pid, end_iso: new Date().toISOString() });

    /*** CONSENT UI ***/
    agree.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));
    ageGroup.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));

    btnStart.addEventListener("click", async () => {
      if (btnStart.disabled) return;
      btnStart.disabled = true;
      startInfo.innerHTML = `<span class="loader"></span> contacting serverâ€¦`;

      pid = q.get("pid") || localStorage.getItem("ts_pid") || uuid();
      localStorage.setItem("ts_pid", pid);

      try {
        const r = await participantStart(pid, ageGroup.value);
        deviceOrder = r.device_order || (r.status && r.status.device_order);
        localStorage.setItem("ts_order", deviceOrder);
        startInfo.textContent = `PID: ${pid} | Order: ${deviceOrder}`;

        const dev = getDevice()
        const [first, second] = deviceOrder.split("â†’");
        const st = r.status || await getStatus(pid);

        if (st.completed) { return cycleToNewParticipant(); }

        if (!st.phase1_done && dev === first) { phase = 1; gotoTrialWithLoading(); }
        else if (st.phase1_done && !st.phase2_done && dev === second) { phase = 2; gotoTrialWithLoading(); }
        else {
          // If weâ€™re at the wrong device for Phase 1, show a Phase 1 link but wait for Phase 2.
          if (!st.phase1_done) {
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 1);
          } else {
            // Wrong device for Phase 2 (rare): just wait for Phase 2 (and link to Phase 2)
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
        }
        // If we'd hand this device off for phase 1 and there is NO pid in the URL,
        // assume it's a stale local PID and start a fresh participant.
        if (!q.get("pid") && phase === 1 && dev === first && st.phase1_done) {
          pid = uuid();
          localStorage.setItem("ts_pid", pid);
          const r2 = await participantStart(pid, ageGroup.value);
          deviceOrder = r2.device_order || (r2.status && r2.status.device_order);
          localStorage.setItem("ts_order", deviceOrder);
          phase = 1; gotoTrialWithLoading();
          return;
        }
      } catch (err) {
        startInfo.textContent = "Error starting. Refresh and try again.";
        btnStart.disabled = false;
      }
    });

    /*** DIRECT PHASE LINKS (from QR/handoff) ***/
    window.addEventListener("DOMContentLoaded", async () => {
      const pidQ = q.get("pid"), orderQ = q.get("order"), phaseQ = Number(q.get("phase") || 0);
      // If there is NO pid in the URL, clear any stale local session
      if (!pidQ) {
        localStorage.removeItem("ts_pid");
        localStorage.removeItem("ts_order");
        localStorage.removeItem("ts_wait_phase");
        localStorage.removeItem("ts_handoff_url");
      }
      // If there IS a pid in the URL, it takes precedence over localStorage
      // (this allows reloading the handoff link without breaking)
      if (pidQ && orderQ && (phaseQ === 1 || phaseQ === 2)) {
        pid = pidQ; deviceOrder = orderQ; phase = phaseQ;
        localStorage.setItem("ts_pid", pid);
        localStorage.setItem("ts_order", deviceOrder);

        hide(sConsent); show(sHandoff); // brief state so user sees progress
        hideEl(qrWrap);          // hide QR while weâ€™re just â€œpreparingâ€¦â€
        waitTxt.textContent = `Preparing Phase ${phase}â€¦`;

        // ðŸ”‘ Ensure server row exists & fetch authoritative order
        try {
          const r = await participantStart(pid, ""); // idempotent
          deviceOrder = r.device_order || (r.status && r.status.device_order) || deviceOrder;
          localStorage.setItem("ts_order", deviceOrder);
        } catch (e) { }

        // If wrong device, keep handoff; otherwise go into trial
        const dev = getDevice(); const [first, second] = deviceOrder.split("â†’");
        if ((phase === 1 && dev !== first) || (phase === 2 && dev !== second)) {
          // explicit â€œwrong deviceâ€ page instead of the generic handoff card
          showWrongDevice(phase);
        } else {
          gotoTrialWithLoading();
        }
        return;
      }

      // If page was refreshed while waiting, resume the handoff view
      const waitPhase = Number(localStorage.getItem("ts_wait_phase") || 0);
      const storedPid = localStorage.getItem("ts_pid");
      const storedOrd = localStorage.getItem("ts_order");
      if (!pidQ && waitPhase && storedPid && storedOrd) {
        pid = storedPid; deviceOrder = storedOrd; phase = waitPhase;
        showHandoff(getDevice(), waitPhase);
        return;
      }

      show(sConsent);
    });

    /*** TRIAL ***/
    function gotoTrialWithLoading() {
      stopPoll();
      hide(sConsent); hide(sHandoff); show(sTrial);
      setSpin(true); statusEl.textContent = `Preparing Phase ${phase}â€¦`;
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()}`;
      if (roundIdx !== -1 && phase === 1) roundIdx = roundIdx; // no-op for P1 if you arrive mid-session
      setTimeout(gotoTrial, 150); // tiny delay lets UI paint the loading state
    }

    function gotoTrial() {
      setSpin(false);
      statusEl.textContent = "Ready";

      // Set the sentence + labels for this round
      const s = currentSentence();
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()} â€” ${phaseRoundLabel()}`;
      trialHelp.textContent = s.isPractice
        ? "Practice: type exactly what you see. When it matches, weâ€™ll move on to Round 1."
        : (roundIdx === 0 ? "Round 1/3: type the sentence exactly. It will submit automatically."
          : `Round ${s.order}/3: type the sentence exactly.`);

      // reset timers & buffers
      keystrokes = [];
      backspaces = 0;
      paused500 = 0;
      submitting = false;
      frozen = false;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      lastT = 0;
      timerEl.textContent = "0 ms"; // ensure the UI resets

      sentenceEl.textContent = s.text;
      textarea.value = "";
      textarea.disabled = false;
      textarea.focus();

      // reset timers & buffers
      keystrokes = []; backspaces = 0; paused500 = 0; submitting = false; frozen = false;
      t0 = 0; lastT = 0; if (rafId) cancelAnimationFrame(rafId);

      // start timer on first key
      const startTimerOnce = () => {
        if (!t0) { t0 = ms(); lastT = t0; tick(); }
        textarea.removeEventListener("keydown", startTimerOnce);
      };
      textarea.addEventListener("keydown", startTimerOnce, { once: true });

      textarea.onkeydown = (e) => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        if (e.key === "Backspace") backspaces++;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "keydown",
          key: e.key,
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });
      };

      textarea.oninput = () => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "input",
          key: "",
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });

        // match against current round sentence (trim trailing space/newline)
        const typed = textarea.value.replace(/\s+$/, "");
        const target = currentSentence().text.replace(/\s+$/, "");
        if (!submitting && typed === target) submitTrial();
      };

      textarea.onpaste = (e) => e.preventDefault();
    }

    /*** SUBMIT ***/
    async function submitTrial() {
      submitting = true;
      textarea.disabled = true;
      setSpin(true);
      statusEl.textContent = "Submittingâ€¦";

      // stop timer now
      frozen = true;
      if (rafId) cancelAnimationFrame(rafId);
      if (t0) timerEl.textContent = `${Math.round(ms() - t0)} ms`;

      // timing summary
      const end = ms(), total = Math.round(end - (t0 || end));
      const deltas = [];
      for (let i = 1; i < keystrokes.length; i++) deltas.push(keystrokes[i].t_ms - keystrokes[i - 1].t_ms);
      const mean = deltas.length ? Math.round(deltas.reduce((a, b) => a + b, 0) / deltas.length) : 0;
      const p95 = deltas.length ? Math.round(deltas.sort((a, b) => a - b)[Math.floor(0.95 * (deltas.length - 1))]) : 0;

      const s = currentSentence();

      // Practice trial: donâ€™t send to backendâ€”just advance to Round 1
      if (s.isPractice) {
        setSpin(false);
        statusEl.textContent = "Nice! Practice done â€” starting Round 1â€¦";
        roundIdx = 0;           // begin recorded rounds
        setTimeout(gotoTrialWithLoading, 500);
        return;
      }

      // Recorded trial â†’ send to backend
      const payload = {
        type: "trial_summary",
        pid,
        trial_id: `P${phase}-R${s.order}`,          // e.g., P1-R2
        device: getDevice(),
        sentence_id: s.id,                          // S1/S2/S3
        order_in_block: s.order,                    // 1..3 (0 was practice)
        start_ms: 0, end_ms: total, total_ms: total,
        mean_interkey_ms: mean, p95_interkey_ms: p95,
        pause500_count: paused500, backspace_count: backspaces,
        ua: navigator.userAgent, os: "unknown", browser: "unknown",
        screen_w: screen.width, screen_h: screen.height, dpr: devicePixelRatio,
        paste_attempted: false, focus_blur_count: 0, flags: "proto-v3"
      };

      try {
        const r = await trialSummary(payload);
        setSpin(false);
        if (!r.ok) throw new Error(r.error || "submit failed");

        // More recorded rounds left in this phase?
        if (roundIdx + 1 < TOTAL_TEST_ROUNDS) {
          roundIdx += 1;
          statusEl.textContent = `Saved. Starting ${roundIdx + 1 < TOTAL_TEST_ROUNDS ? `Round ${roundIdx + 1 + 1}` : "final round"}â€¦`;
          setTimeout(gotoTrialWithLoading, 500);
          return;
        }

        // Phase finished (3 recorded trials)
        // r.next already comes from backendâ€™s phase flags. Weâ€™ll still follow your handoff logic:
        if (r.next === 2) {
          // Phase 1 just finished â†’ show handoff to Phase 2
          const devNow = getDevice();
          statusEl.textContent = devNow === "laptop"
            ? "Phase 1 complete. Use the link/QR below to continue on your phone."
            : "Phase 1 complete. This page will help you continue on your other device.";
          roundIdx = -1; // reset so Phase 2 starts with practice again
          showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          return;
        }

        if (r.next === "done") {
          // Phase 2 finished â†’ close the loop
          try { await participantEnd(pid); } catch { }
          showDoneAndCycle();
          return;
        }

        // Fallback: if backend says still same phase (unlikely), start over safely
        statusEl.textContent = "Saved. Preparing next stepâ€¦";
        setTimeout(gotoTrialWithLoading, 400);

      } catch (e) {
        statusEl.textContent = "Network error â€” try again";
        textarea.disabled = false; submitting = false;
      }
    }

    // --- HANDOFF CARD (shows link/QR, polls, and auto-switches when ready) ---
    function showHandoff(currentDevice, waitPhase, linkPhase = waitPhase) {
      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("â†’");
      const orderStr = order.join("â†’") || (deviceOrder || "");
      const linkTargetDevice = (linkPhase === 1 ? order[0] : order[1]) || "phone";
      const link = handoffLink(pid, orderStr, linkPhase);

      const isWrongStartWithP1Link = (waitPhase === 2 && linkPhase === 1);
      const isP1JustFinishedOnLaptop =
        (currentDevice === "laptop") && (linkPhase === 2) && (linkTargetDevice === "phone");

      // Is this a â€œpreparingâ€ screen? (weâ€™re waiting for this same phase)
      const isPreparing = (linkPhase === waitPhase);

      // Title
      const handoffTitle = document.getElementById("handoffTitle");
      handoffTitle.textContent = (linkPhase === 1) ? "Start on your other device"
        : "Continue on your other device";

      // Message
      if (isWrongStartWithP1Link) {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. After finishing Phase 1 on your <b>${order[0]}</b>, ` +
          `<b>this page</b> will automatically switch to Phase 2 on your <b>${order[1]}</b>.`;
      } else if (isP1JustFinishedOnLaptop) {
        handoffMsg.innerHTML =
          `Phase 1 on your <b>laptop</b> is done. Use the link (or QR) below to start Phase 2 on your <b>phone</b>.`;
      } else {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. Please continue on your <b>${linkTargetDevice}</b>.`;
      }

      // â€œWaitingâ€¦â€ copy
      waitTxt.textContent = isWrongStartWithP1Link
        ? "Waiting to complete Phase 1 on your other deviceâ€¦"
        : (isPreparing
          ? `Preparing Phase ${waitPhase}â€¦`
          : (waitPhase === 2 ? "Waiting for Phase 2 to be readyâ€¦" : "Waitingâ€¦"));

      // Link + copy
      handoffUrl.textContent = link;
      btnCopy.onclick = async () => {
        try { await navigator.clipboard.writeText(link); btnCopy.textContent = "Copied!"; }
        catch { }
        setTimeout(() => btnCopy.textContent = "Copy link", 1200);
      };

      // QR visibility rules:
      // - Show only on *laptop* (phones can open links directly)
      // - Show only when the link targets the *phone*
      // - Never on â€œpreparingâ€ views (linkPhase === waitPhase)
      const shouldShowQR = (currentDevice === "laptop") &&
        (linkTargetDevice === "phone") &&
        !isPreparing;

      if (shouldShowQR) {
        showEl(qrWrap);
        setTimeout(() => { qrImg.src = qrFor(link); }, 0);
      } else {
        hideEl(qrWrap);
        qrImg.removeAttribute("src");
      }

      // Show handoff card
      statusEl.textContent = "";
      setSpin(false);
      hide(sTrial); hide(sConsent); show(sHandoff);

      // Persist & poll for *waitPhase*
      localStorage.setItem("ts_wait_phase", String(waitPhase));
      localStorage.setItem("ts_handoff_url", link);
      startHandoffPolling(waitPhase);
    }


    /*** DONE + AUTO-CYCLE ***/
    function showDoneAndCycle() {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sDone);
      pidOut.textContent = pid;
      setTimeout(cycleToNewParticipant, 3000);
      stopPoll();
    }
    function cycleToNewParticipant() {
      localStorage.removeItem("ts_pid"); localStorage.removeItem("ts_order");
      location.replace(baseURL()); // clean URL (drops pid/order/phase)
    }
    function currentSentence() {
      if (roundIdx < 0) return { text: SENTENCES.practice, id: SENTENCES.ids.practice, order: 0, isPractice: true };
      return {
        text: SENTENCES.tests[roundIdx],
        id: SENTENCES.ids.tests[roundIdx],
        order: roundIdx + 1,
        isPractice: false
      };
    }

    function phaseRoundLabel() {
      if (roundIdx < 0) return "Practice";
      return `Round ${roundIdx + 1} of ${TOTAL_TEST_ROUNDS}`;
    }

    // --- WRONG DEVICE (opened a phase link on the wrong device) ---
    function showWrongDevice(targetPhase) {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sWrong);

      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("â†’");
      const targetDevice = targetPhase === 1 ? (order[0] || "phone") : (order[1] || "laptop");
      const link = handoffLink(pid, (order.join("â†’") || deviceOrder || ""), targetPhase);

      wrongMsg.innerHTML =
        `This link is for your <b>${targetDevice}</b> (Phase ${targetPhase}). ` +
        `Youâ€™re on a <b>${getDevice()}</b>. Please open it on the other device.`;

      wrongUrl.textContent = link;

      const showQR = (getDevice() === "laptop") && (targetDevice === "phone");
      const qrBox = wrongQr.parentElement;
      if (showQR) {
        showEl(qrBox);
        setTimeout(() => { wrongQr.src = qrFor(link); }, 0);
      } else {
        hideEl(qrBox);
        wrongQr.removeAttribute("src");
      }

      localStorage.setItem("ts_wait_phase", String(targetPhase));
      localStorage.setItem("ts_handoff_url", link);
    }

    function stopPoll() { if (pollId) { clearInterval(pollId); pollId = null; } }

    function startHandoffPolling(waitPhase) {
      stopPoll();
      pollId = setInterval(async () => {
        if (sHandoff.classList.contains("hidden")) { stopPoll(); return; }

        const st = await getStatus(pid);
        const [first, second] = (deviceOrder || "").split("â†’");
        const dev = getDevice();

        // If weâ€™re waiting for Phase 2 and this device is the Phase 2 device,
        // start as soon as Phase 1 is done.
        if (waitPhase === 2 && dev === second && st.phase1_done && !st.phase2_done) {
          stopPoll();
          phase = waitPhase;
          gotoTrialWithLoading();
          roundIdx = -1; // start Phase 2 with practice
          return;
        }

        // If everything finished elsewhere, reset this tab.
        if (st.completed) {
          stopPoll();
          cycleToNewParticipant();
        }
      }, 2000);
    }
  </script>
</body>

</html>