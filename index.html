<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Study ‚Äî Minimal Prototype</title>
  <style>
    :root {
      --muted: #666;
      --b: #ddd;
      --r: 12px
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 720px;
      margin: 24px auto;
      line-height: 1.45
    }

    h1 {
      font-size: 1.25rem;
      margin-bottom: .25rem
    }

    .muted {
      color: var(--muted);
      font-size: .92rem;
      margin: .25rem 0
    }

    .card {
      border: 1px solid var(--b);
      border-radius: var(--r);
      padding: 16px;
      margin: 16px 0
    }

    .hidden {
      display: none
    }

    textarea {
      width: 100%;
      min-height: 140px;
      font-size: 1rem
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      cursor: pointer
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .row>* {
      flex: 1
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .center {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      border: 1px solid var(--b);
      border-radius: 999px;
      padding: .25rem .6rem .25rem .35rem
    }

    .loader {
      width: 14px;
      height: 14px;
      border: 2px solid #bbb;
      border-top-color: #444;
      border-radius: 50%;
      animation: spin 1s linear infinite
    }

    @keyframes spin {
      to {
        transform: rotate(360deg)
      }
    }

    .linkbox {
      border: 1px dashed var(--b);
      border-radius: 10px;
      padding: 10px;
      margin-top: 8px;
      background: #fafafa
    }

    img.qr {
      width: 140px;
      height: 140px;
      border: 1px solid var(--b);
      border-radius: 8px;
      background: #fff
    }

    .ok {
      color: #137333
    }

    .warn {
      color: #b06000
    }

    #s-boot {
      transition: opacity 0.3s ease;
    }

    #s-boot.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <h1>Typing Study</h1>
  <p class="muted">Test your typing speed on both your laptop keyboard and mobile device.</p>

  <section id="s-consent" class="card hidden">
    <h2>Consent</h2>
    <p>
      After you give consent and choose your age group, the server will randomly assign you
      a device order ‚Äî <b>phone‚Üílaptop</b> or <b>laptop‚Üíphone</b> ‚Äî independent of which device you‚Äôre using right now.
      If this device isn‚Äôt first, we‚Äôll show a link (and a QR on laptops) to open Phase 1 on your other device.
      When Phase 1 finishes, this tab will automatically load Phase 2. <br><br>
      If this device <b>is</b> the first one in your assigned order, you‚Äôll begin Phase 1 right here.
      After completing Phase 1, you‚Äôll receive a link (and QR if on a laptop) to continue Phase 2 on your other device.
      No personal information is collected.
    </p>
    <label class="center" style="gap:.6rem">
      <input id="agree" type="checkbox" /> I am 18‚Äì22 or 35‚Äì55 and I consent.
    </label>
    <div class="row" style="margin-top:12px">
      <select id="ageGroup">
        <option value="">Age group‚Ä¶</option>
        <option>18‚Äì22</option>
        <option>35‚Äì55</option>
      </select>
      <button id="btnStart" disabled>Start</button>
    </div>
    <p id="startInfo" class="mono muted"></p>
  </section>

  <section id="s-boot" class="card">
    <h2>Restoring session‚Ä¶</h2>
    <p class="muted">Please wait a moment.</p>
  </section>

  <!-- Handoff card -->
  <section id="s-handoff" class="card hidden">
    <h2 id="handoffTitle"></h2>
    <p id="handoffMsg" class="muted"></p>

    <!-- QR/link row -->
    <div class="row" style="align-items: start;">
      <div class="grow">
        <code id="handoffUrl" class="mono" style="word-break: break-all;"></code>
        <div style="margin-top: 8px;">
          <!-- inside the handoff card header row -->
          <div id="copyWrap">
            <button id="btnCopy" class="btn">Copy link</button>
          </div>
        </div>
      </div>

      <!-- üëâ Wrap BOTH the QR image AND the caption in the same container -->
      <div id="qrWrap" class="hidden" style="text-align:center;">
        <img id="qrImg" alt="QR" style="width:140px;height:140px;display:block;margin:0 auto;" />
        <div id="qrCap" class="muted" style="margin-top:6px;">Scan this QR with your other device‚Äôs camera.</div>
      </div>
    </div>

    <p id="waitTxt" class="muted" style="margin-top:12px;"></p>
  </section>

  <section id="s-wrong" class="card hidden">
    <h2 class="warn">Use your other device</h2>
    <p id="wrongMsg" class="muted"></p>
    <div class="linkbox">
      <div class="mono" id="wrongUrl" style="word-break:break-all"></div>
    </div>
    <div class="center" style="gap:16px;margin-top:10px">
      <img id="wrongQr" class="qr" alt="QR code" />
      <div class="muted">Open this on your other device, or scan the QR.</div>
    </div>
  </section>

  <section id="s-trial" class="card hidden">
    <h2>Type Exactly What You See</h2>
    <p id="trialHelp" class="muted"></p>
    <p id="phaseLabel" class="muted"></p>
    <p id="sentence" class="mono"></p>
    <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
      placeholder="Type the sentence here. It will submit automatically."></textarea>
    <div class="row" style="margin-top:8px">
      <div class="pill"><span id="spin" class="loader hidden"></span><span id="status" class="muted">Ready</span></div>
      <div id="timer" class="mono" style="text-align:right">0 ms</div>
    </div>
    <p class="muted">Tip: don‚Äôt paste; type it out. Backspace is allowed.
      If you make a mistake, just correct it and continue typing.
      When your input matches the sentence exactly, it will submit automatically.
      If it doesn't submit, check for extra spaces or newlines at the end.
      You can refresh the page at any time to resume your progress.
    </p>
  </section>

  <section id="s-done" class="card hidden">
    <h2 class="ok">Done ‚úÖ</h2>
    <p>Thanks! Data sent. Your participant ID:</p>
    <p class="mono" id="pidOut"></p>
    <p class="muted">This page will reset for the next participant automatically.</p>
  </section>

  <script>
    /*** CONFIG ***/
    const ENDPOINT = "https://script.google.com/macros/s/AKfycbz5dTthOWO4crOgte-hUWlIDR4bM2LgLshVOdV-BacKt606Ob8B5dKLxLHB2BalhYG0sg/exec";
    // Sentences: 1 practice + 3 test sentences (same on both devices)
    const SENTENCES = {
      practice: "The quick brown fox jumps over a sleepy dog in the park.",           // practice
      tests: [
        "Many people find typing on a smartphone harder than on a laptop keyboard.",  // test 1
        "Machine learning can analyze how fast people type under different conditions to improve technology accessibility.", // test 2
        "Data collected from typing tasks can reveal patterns in human performance and guide interface design."              // test 3
      ],
      ids: { practice: "P", tests: ["S1", "S2", "S3"] } // IDs you‚Äôll see in the sheet
    };

    /*** DOM ***/
    const sConsent = document.getElementById("s-consent");
    const sHandoff = document.getElementById("s-handoff");
    const sTrial = document.getElementById("s-trial");
    const sDone = document.getElementById("s-done");
    const agree = document.getElementById("agree");
    const ageGroup = document.getElementById("ageGroup");
    const btnStart = document.getElementById("btnStart");
    const startInfo = document.getElementById("startInfo");
    const handoffMsg = document.getElementById("handoffMsg");
    const handoffUrl = document.getElementById("handoffUrl");
    const btnCopy = document.getElementById("btnCopy");
    const qrImg = document.getElementById("qrImg");
    const qrWrap = document.getElementById("qrWrap");
    const sentenceEl = document.getElementById("sentence");
    const textarea = document.getElementById("input");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const spinEl = document.getElementById("spin");
    const phaseLabel = document.getElementById("phaseLabel");
    const pidOut = document.getElementById("pidOut");
    const waitTxt = document.getElementById("waitTxt");
    const sWrong = document.getElementById("s-wrong");
    const wrongMsg = document.getElementById("wrongMsg");
    const wrongUrl = document.getElementById("wrongUrl");
    const wrongQr = document.getElementById("wrongQr");
    const trialHelp = document.getElementById("trialHelp");
    const copyWrap = document.getElementById("copyWrap");
    const sBoot = document.getElementById("s-boot");
    const hideBoot = () => sBoot && sBoot.classList.add("hidden");

    /*** STATE ***/
    let pid = null, deviceOrder = null, phase = 1;
    let t0 = 0, lastT = 0, rafId = null, frozen = false;
    let keystrokes = [], backspaces = 0, paused500 = 0, submitting = false;
    let pollId = null;
    // Round control: -1 = practice, then 0,1,2 are test rounds
    let roundIdx = -1;               // start with practice
    const TOTAL_TEST_ROUNDS = 3;     // 3 recorded rounds per phase

    /*** UTIL ***/
    const q = new URLSearchParams(location.search);
    const ms = () => performance.now();
    const show = el => el.classList.remove("hidden");
    const hide = el => el.classList.add("hidden");
    const hideEl = (el) => el.classList.add("hidden");
    const showEl = (el) => el.classList.remove("hidden");
    const setSpin = on => spinEl.classList.toggle("hidden", !on);
    const getDevice = () => /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? "phone" : "laptop";
    const uuid = () => "TS-" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const baseURL = () => location.origin + location.pathname;
    function handoffLink(pid, order, targetPhase) { const u = new URL(baseURL()); u.searchParams.set("pid", pid); u.searchParams.set("order", order); u.searchParams.set("phase", targetPhase); return u.toString(); }
    const qrFor = url => "https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=" + encodeURIComponent(url);

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const currentDevice = isMobile ? "phone" : "laptop";
    function splitOrder(orderStr) {
      const [firstDev, secondDev] = (orderStr || "").split("‚Üí");
      return { firstDev, secondDev };
    }

    // --- URL helpers ------------------------------------------------------------
    function stripQueryParams(keys) {
      try {
        const url = new URL(location.href);
        keys.forEach(k => url.searchParams.delete(k));
        history.replaceState(null, "", url);
      } catch { /* noop */ }
    }

    function setQueryParam(k, v) {
      try {
        const url = new URL(location.href);
        if (v == null) url.searchParams.delete(k);
        else url.searchParams.set(k, String(v));
        history.replaceState(null, "", url);
      } catch { /* noop */ }
    }

    // ---- Session token (per PID) ----
    const TOK_KEY = "ts_token";
    const PHASE_KEY = "ts_phase";
    const ROUND_KEY = "ts_round";

    function setTok(t) { if (t) localStorage.setItem(TOK_KEY, t); }
    function getTok() { return localStorage.getItem(TOK_KEY) || ""; }
    function clearTok() { localStorage.removeItem(TOK_KEY); }

    // ---- Progress persistence (phase + roundIdx) ----
    function saveProgress() {
      localStorage.setItem(PHASE_KEY, String(phase));
      localStorage.setItem(ROUND_KEY, String(roundIdx));
    }
    function loadProgress() {
      const p = Number(localStorage.getItem(PHASE_KEY) || 0);
      const r = Number(localStorage.getItem(ROUND_KEY) || -999);
      if (p === 1 || p === 2) phase = p;
      if (r >= -1 && r <= 2) roundIdx = r; // -1 practice, 0..2 tests
    }
    function clearProgress() {
      localStorage.removeItem(PHASE_KEY);
      localStorage.removeItem(ROUND_KEY);
    }

    // ---- Facilitator reset (visit with ?reset=1) ----
    if (q.get("reset") === "1") {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      clearTok();
      // drop query params so the page reloads clean
      location.replace(location.origin + location.pathname);
    }

    /*** BACKEND ***/
    async function post(body) {
      const r = await fetch(ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "text/plain" },
        body: JSON.stringify(body)    // no secret; backend verifies pid+session_token
      });
      return r.json();
    }

    // participant_start (no token required; returns session_token)
    const participantStart = (pid, age) => post({
      type: "participant_start",
      pid,
      age_group: age || "",
      consent_version: "v1",
      start_iso: new Date().toISOString()
    });

    // status (token required)
    const getStatus = (pid) => post({
      type: "status",
      pid,
      session_token: getTok()
    });

    // trial_summary (token required)
    const trialSummary = (payload) => post({
      type: "trial_summary",
      session_token: getTok(),
      ...payload
    });

    // participant_end (token required)
    const participantEnd = (pid) => post({
      type: "participant_end",
      pid,
      session_token: getTok(),
      end_iso: new Date().toISOString()
    });

    /*** CONSENT UI ***/
    agree.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));
    ageGroup.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));

    btnStart.addEventListener("click", async () => {
      if (btnStart.disabled) return;
      btnStart.disabled = true;
      startInfo.innerHTML = `<span class="loader"></span> contacting server‚Ä¶`;

      // If we‚Äôre starting from the consent page (no pid in URL), always mint a fresh PID
      pid = q.get("pid") || uuid();
      localStorage.setItem("ts_pid", pid);

      try {
        const r = await participantStart(pid, ageGroup.value);

        if (r && r.session_token) setTok(r.session_token);

        deviceOrder = r.device_order || (r.status && r.status.device_order);
        localStorage.setItem("ts_order", deviceOrder);
        startInfo.textContent = `PID: ${pid} | Order: ${deviceOrder}`;

        const dev = getDevice()
        const [first, second] = deviceOrder.split("‚Üí");
        const st = r.status || await getStatus(pid);

        if (st.completed) { return cycleToNewParticipant(); }

        if (!st.phase1_done && dev === first) { phase = 1; gotoTrialWithLoading(); }
        else if (st.phase1_done && !st.phase2_done && dev === second) { phase = 2; gotoTrialWithLoading(); }
        else {
          // If we‚Äôre at the wrong device for Phase 1, show a Phase 1 link but wait for Phase 2.
          if (!st.phase1_done) {
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 1);
          } else {
            // Wrong device for Phase 2 (rare): just wait for Phase 2 (and link to Phase 2)
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
        }
        // If we'd hand this device off for phase 1 and there is NO pid in the URL,
        // assume it's a stale local PID and start a fresh participant.
        if (!q.get("pid") && phase === 1 && dev === first && st.phase1_done) {
          pid = uuid();
          localStorage.setItem("ts_pid", pid);
          const r2 = await participantStart(pid, ageGroup.value);

          if (r2 && r2.session_token) setTok(r2.session_token);

          deviceOrder = r2.device_order || (r2.status && r2.status.device_order);
          localStorage.setItem("ts_order", deviceOrder);
          phase = 1; gotoTrialWithLoading();
          return;
        }
      } catch (err) {
        startInfo.textContent = "Error starting. Refresh and try again.";
        btnStart.disabled = false;
      }
    });

    // --- Smart resume on refresh anywhere after Start ---
    window.addEventListener("DOMContentLoaded", async () => {
      // Show boot screen immediately (consent is hidden initially)
      // sBoot is visible by default

      const pidQ = q.get("pid");
      const orderQ = q.get("order");
      const phaseQ = Number(q.get("phase") || 0);

      // Case A: Direct phase link (other device open)
      if (pidQ && orderQ && (phaseQ === 1 || phaseQ === 2)) {
        try {
          // Persist pid/order/phase locally
          pid = pidQ;
          deviceOrder = orderQ;
          phase = phaseQ;
          localStorage.setItem("ts_pid", pid);
          localStorage.setItem("ts_order", deviceOrder);
          localStorage.setItem("ts_phase", String(phase));

          // Mint/get token idempotently (no consent needed)
          const r = await participantStart(pid, "");
          if (r && r.session_token) setTok(r.session_token);

          // Use authoritative order + status
          const ord = (r.device_order || (r.status && r.status.device_order) || deviceOrder);
          if (ord) {
            deviceOrder = ord;
            localStorage.setItem("ts_order", deviceOrder);
          }
          const st = r.status || await getStatus(pid);
          if (!st || st.ok === false) throw new Error("status failed");

          const { firstDev, secondDev } = splitOrder(deviceOrder);
          const devNow = currentDevice;

          // *** Gate the URL's phase by real server status ***
          if (phaseQ === 1) {
            if (st.phase1_done) {
              // Phase 1 already finished ‚Üí ignore stale ?phase=1
              stripQueryParams(["phase"]);
              if (!st.phase2_done) {
                // Route to Phase 2 or its handoff
                if (devNow === secondDev) {
                  phase = 2;
                  localStorage.setItem("ts_phase", "2");
                  localStorage.setItem("ts_page", "trial");
                  gotoTrialWithLoading();
                } else {
                  localStorage.setItem("ts_page", "handoff");
                  showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
                }
                return;
              } else {
                showDoneAndCycle();
                return;
              }
            } else {
              // Phase 1 is pending ‚Üí still honor ?phase=1, but only if you‚Äôre on its device
              if (devNow !== firstDev) {
                localStorage.setItem("ts_page", "handoff");
                showWrongDevice(1);
                return;
              }
              localStorage.setItem("ts_page", "trial");
              phase = 1;
              gotoTrialWithLoading();
              return;
            }
          }

          if (phaseQ === 2) {
            if (st.phase2_done) {
              // Already done; ignore stale ?phase=2
              stripQueryParams(["phase"]);
              showDoneAndCycle();
              return;
            } else if (!st.phase1_done) {
              // Can't jump to Phase 2 before Phase 1; ignore ?phase=2 and route properly
              stripQueryParams(["phase"]);
              if (devNow === firstDev) {
                localStorage.setItem("ts_page", "trial");
                phase = 1;
                gotoTrialWithLoading();
              } else {
                localStorage.setItem("ts_page", "handoff");
                showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 1);
              }
              return;
            } else {
              // Phase 2 is pending
              if (devNow !== secondDev) {
                localStorage.setItem("ts_page", "handoff");
                showWrongDevice(2);
                return;
              }
              localStorage.setItem("ts_page", "trial");
              phase = 2;
              gotoTrialWithLoading();
              return;
            }
          }

          // Fallback (shouldn‚Äôt happen)
          stripQueryParams(["phase"]);
        } catch (e) {
          // If something fails, drop into the smart resume fallback below
          console.warn("Direct-link bootstrap failed, falling back:", e);
        }
      }

      // Case B: Smart resume (refresh or returning in the middle)
      try {
        pid = localStorage.getItem("ts_pid") || "";
        deviceOrder = localStorage.getItem("ts_order") || "";
        const tok = getTok();

        if (!pid || !tok) {
          // No session ‚Üí show consent cleanly
          hideBoot();
          show(sConsent);
          return;
        }

        const st = await getStatus(pid);
        if (!st || st.ok === false) throw new Error("status failed");

        // Persist authoritative order
        if (st.device_order) {
          deviceOrder = st.device_order;
          localStorage.setItem("ts_order", deviceOrder);
        }

        if (st.completed) { showDoneAndCycle(); return; }

        const { firstDev, secondDev } = splitOrder(deviceOrder);
        const devNow = currentDevice;

        const pageLS = localStorage.getItem("ts_page");
        const roundLS = localStorage.getItem("ts_roundIdx");
        const preferTrial = (pageLS === "trial");
        if (roundLS != null) { try { roundIdx = parseInt(roundLS, 10); } catch { } }

        if (!st.phase1_done) {
          if (devNow === firstDev) {
            phase = 1;
            localStorage.setItem("ts_phase", "1");
            localStorage.setItem("ts_page", "trial");
            gotoTrialWithLoading();
          } else {
            localStorage.setItem("ts_page", "handoff");
            showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 1);
          }
          return;
        }

        // Phase 1 done
        if (!st.phase2_done) {
          if (devNow === secondDev) {
            phase = 2;
            localStorage.setItem("ts_phase", "2");
            localStorage.setItem("ts_page", "trial");
            gotoTrialWithLoading();
          } else {
            localStorage.setItem("ts_page", "handoff");
            showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
          return;
        }

        // Fallback (shouldn‚Äôt happen since completed would be true)
        showDoneAndCycle();

      } catch (e) {
        console.warn("Resume failed:", e);
        hideBoot();
        show(sConsent);
      }
    });

    /*** TRIAL ***/
    function gotoTrialWithLoading() {
      stopPoll();
      hide(sConsent); hide(sHandoff); show(sTrial);
      hideBoot();
      setSpin(true); statusEl.textContent = `Preparing Phase ${phase}‚Ä¶`;
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()}`;

      localStorage.setItem("ts_page", "trial");
      localStorage.setItem("ts_phase", String(phase));
      localStorage.setItem("ts_roundIdx", String(roundIdx));      // keep updated as rounds advance

      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");

      // ‚§µÔ∏è resume if we crashed/refreshed mid-phase
      loadProgress();
      // Ensure roundIdx is valid for this phase
      if (roundIdx < -1 || roundIdx > 2) roundIdx = -1;

      setTimeout(gotoTrial, 150);
    }

    function tick() {
      if (frozen) return;                  // stop once we submit
      const now = ms();
      const base = t0 || now;              // guard if somehow tick ran pre-start
      timerEl.textContent = `${Math.round(now - base)} ms`;
      rafId = requestAnimationFrame(tick);
    }

    function gotoTrial() {
      setSpin(false);
      statusEl.textContent = "Ready";
      saveProgress();

      // Set the sentence + labels for this round
      const s = currentSentence();
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()} ‚Äî ${phaseRoundLabel()}`;
      trialHelp.innerHTML = s.isPractice
        ? "<span style='color:red; font-weight:bold;'>Practice:</span> type exactly what you see. When it matches, we‚Äôll move on to Round 1."
        : (roundIdx === 0 ? "Round 1/3: type the sentence exactly. It will submit automatically."
          : `Round ${s.order}/3: type the sentence exactly.`);

      // reset timers & buffers
      keystrokes = [];
      backspaces = 0;
      paused500 = 0;
      submitting = false;
      frozen = false;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      lastT = 0;
      timerEl.textContent = "0 ms"; // ensure the UI resets

      sentenceEl.textContent = s.text;
      textarea.value = "";
      textarea.disabled = false;
      textarea.focus();

      // reset timers & buffers
      keystrokes = []; backspaces = 0; paused500 = 0; submitting = false; frozen = false;
      t0 = 0; lastT = 0; if (rafId) cancelAnimationFrame(rafId);

      // start timer on first key
      const startTimerOnce = () => {
        if (!t0) { t0 = ms(); lastT = t0; tick(); }
        textarea.removeEventListener("keydown", startTimerOnce);
      };
      textarea.addEventListener("keydown", startTimerOnce, { once: true });

      textarea.onkeydown = (e) => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        if (e.key === "Backspace") backspaces++;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "keydown",
          key: e.key,
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });
      };

      textarea.oninput = () => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "input",
          key: "",
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });

        // match against current round sentence (trim trailing space/newline)
        const typed = textarea.value.replace(/\s+$/, "");
        const target = currentSentence().text.replace(/\s+$/, "");
        if (!submitting && typed === target) submitTrial();
      };

      textarea.onpaste = (e) => e.preventDefault();
    }

    /*** SUBMIT ***/
    async function submitTrial() {
      submitting = true;
      textarea.disabled = true;
      setSpin(true);
      statusEl.textContent = "Submitting‚Ä¶";

      // stop timer now
      frozen = true;
      if (rafId) cancelAnimationFrame(rafId);
      if (t0) timerEl.textContent = `${Math.round(ms() - t0)} ms`;

      // timing summary
      const end = ms(), total = Math.round(end - (t0 || end));
      const deltas = [];
      for (let i = 1; i < keystrokes.length; i++) deltas.push(keystrokes[i].t_ms - keystrokes[i - 1].t_ms);
      const mean = deltas.length ? Math.round(deltas.reduce((a, b) => a + b, 0) / deltas.length) : 0;
      const p95 = deltas.length ? Math.round(deltas.sort((a, b) => a - b)[Math.floor(0.95 * (deltas.length - 1))]) : 0;

      const s = currentSentence();

      // Practice trial: don‚Äôt send to backend‚Äîjust advance to Round 1
      if (s.isPractice) {
        setSpin(false);
        statusEl.textContent = "Nice! Practice done ‚Äî starting Round 1‚Ä¶";
        roundIdx = 0;           // begin recorded rounds
        saveProgress();
        setTimeout(gotoTrialWithLoading, 500);
        return;
      }

      // Recorded trial ‚Üí send to backend
      const payload = {
        type: "trial_summary",
        pid,
        trial_id: `P${phase}-R${s.order}`,          // e.g., P1-R2
        device: getDevice(),
        sentence_id: s.id,                          // S1/S2/S3
        order_in_block: s.order,                    // 1..3 (0 was practice)
        start_ms: 0, end_ms: total, total_ms: total,
        mean_interkey_ms: mean, p95_interkey_ms: p95,
        pause500_count: paused500, backspace_count: backspaces,
        ua: navigator.userAgent, os: "unknown", browser: "unknown",
        screen_w: screen.width, screen_h: screen.height, dpr: devicePixelRatio,
        paste_attempted: false, focus_blur_count: 0, flags: "proto-v3"
      };

      try {
        const r = await trialSummary(payload);
        setSpin(false);
        if (!r.ok) throw new Error(r.error || "submit failed");

        // More recorded rounds left in this phase?
        if (roundIdx + 1 < TOTAL_TEST_ROUNDS) {
          roundIdx += 1;
          saveProgress();
          statusEl.textContent = `Saved. Starting ${roundIdx + 1 < TOTAL_TEST_ROUNDS ? `Round ${roundIdx + 1 + 1}` : "final round"}‚Ä¶`;
          setTimeout(gotoTrialWithLoading, 500);
          return;
        }

        // Phase finished (3 recorded trials)
        // r.next already comes from backend‚Äôs phase flags. We‚Äôll still follow your handoff logic:
        if (r.next === 2) {
          const devNow = getDevice();
          statusEl.textContent = devNow === "laptop"
            ? "Phase 1 complete. Use the link/QR below to continue on your phone."
            : "Phase 1 complete. This page will help you continue on your other device.";
          roundIdx = -1; // reset so Phase 2 starts with practice again

          // Kill stale ?phase=1 from the P1 device URL so a refresh can‚Äôt jump back into Phase 1.
          stripQueryParams(["phase"]);

          showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          return;
        }

        if (r.next === "done") {
          // Phase 2 finished ‚Üí close the loop
          try { await participantEnd(pid); } catch { }
          clearProgress()
          clearTok();
          showDoneAndCycle();
          return;
        }

        // Fallback: if backend says still same phase (unlikely), start over safely
        statusEl.textContent = "Saved. Preparing next step‚Ä¶";
        setTimeout(gotoTrialWithLoading, 400);

      } catch (e) {
        statusEl.textContent = "Network error ‚Äî try again";
        textarea.disabled = false; submitting = false;
      }
    }

    // --- HANDOFF CARD (shows link/QR, polls, and auto-switches when ready) ---
    function showHandoff(currentDevice, waitPhase, linkPhase = waitPhase) {
      // NEW: this page is not a trial; remove stale ?phase=... so refresh can‚Äôt resurrect old phase.
      stripQueryParams(["phase"]);
      localStorage.setItem("ts_page", "handoff");
      localStorage.removeItem("ts_roundIdx");

      hide(sConsent); hide(sTrial); hideBoot(); show(sHandoff);
      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("‚Üí");
      const orderStr = order.join("‚Üí") || (deviceOrder || "");
      const linkTargetDevice = (linkPhase === 1 ? order[0] : order[1]) || "phone";
      const link = handoffLink(pid, orderStr, linkPhase);

      localStorage.setItem("ts_page", "handoff");

      // "Preparing" only when this device is the one that will run the linked phase
      const isPreparing = (currentDevice === linkTargetDevice) && (linkPhase === waitPhase);

      const isWrongStartWithP1Link = (waitPhase === 2 && linkPhase === 1);
      const isP1JustFinishedOnLaptop =
        (currentDevice === "laptop") && (linkPhase === 2) && (linkTargetDevice === "phone");

      // Title
      const handoffTitle = document.getElementById("handoffTitle");
      handoffTitle.textContent = (linkPhase === 1) ? "Start on your other device"
        : "Continue on your other device";

      // Message
      if (isWrongStartWithP1Link) {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. After finishing Phase 1 on your <b>${order[0]}</b>, ` +
          `<b>this page</b> will automatically switch to Phase 2 on your <b>${order[1]}</b>.`;
      } else if (isP1JustFinishedOnLaptop) {
        handoffMsg.innerHTML =
          `Phase 1 on your <b>laptop</b> is done. Use the link (or QR) below to start Phase 2 on your <b>phone</b>.`;
      } else {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. Please continue on your <b>${linkTargetDevice}</b>.`;
      }

      // Waiting copy
      waitTxt.textContent = isWrongStartWithP1Link
        ? "Waiting to complete Phase 1 on your other device‚Ä¶"
        : (isPreparing ? `Preparing Phase ${waitPhase}‚Ä¶`
          : (waitPhase === 2 ? "Waiting for Phase 2 to be ready‚Ä¶" : "Waiting‚Ä¶"));

      // Link + copy button
      // Link text (always useful when not preparing)
      handoffUrl.textContent = link;

      // Hide the copy button whenever this device is preparing to actually run the phase.
      if (isPreparing) {
        if (copyWrap) {
          copyWrap.style.display = "none";   // hide entire div
        }
        if (btnCopy) {
          btnCopy.style.display = "none";    // also hide button itself
          btnCopy.disabled = true;
        }
      } else {
        if (copyWrap) {
          copyWrap.style.display = "";       // restore normal visibility
        }
        if (btnCopy) {
          btnCopy.style.display = "";
          btnCopy.disabled = false;
          btnCopy.onclick = async () => {
            try { await navigator.clipboard.writeText(link); btnCopy.textContent = "Copied!"; }
            catch { }
            setTimeout(() => (btnCopy.textContent = "Copy link"), 1200);
          };
        }
      }

      // QR visibility
      // - only on laptop
      // - only when the link targets the phone
      // - never on "preparing" views
      const shouldShowQR =
        (currentDevice === "laptop") &&
        (linkTargetDevice === "phone") &&
        !isPreparing;

      if (shouldShowQR) {
        showEl(qrWrap);              // shows image + caption; no empty box
        setTimeout(() => { qrImg.src = qrFor(link); }, 0);
      } else {
        hideEl(qrWrap);
        qrImg.removeAttribute("src");
      }

      // Show card
      statusEl.textContent = "";
      setSpin(false);
      hideBoot();
      hide(sTrial); hide(sConsent); show(sHandoff);

      // Persist + poll for the phase we‚Äôre waiting on
      localStorage.setItem("ts_wait_phase", String(waitPhase));
      localStorage.setItem("ts_handoff_url", link);
      startHandoffPolling(waitPhase);
    }

    /*** DONE + AUTO-CYCLE ***/
    function showDoneAndCycle() {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sDone);
      pidOut.textContent = pid;
      setTimeout(cycleToNewParticipant, 3000);
      stopPoll();
    }
    function cycleToNewParticipant() {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      clearProgress();
      clearTok();
      location.replace(baseURL());
    }
    function currentSentence() {
      if (roundIdx < 0) return { text: SENTENCES.practice, id: SENTENCES.ids.practice, order: 0, isPractice: true };
      return {
        text: SENTENCES.tests[roundIdx],
        id: SENTENCES.ids.tests[roundIdx],
        order: roundIdx + 1,
        isPractice: false
      };
    }

    function phaseRoundLabel() {
      if (roundIdx < 0) return "Practice";
      return `Round ${roundIdx + 1} of ${TOTAL_TEST_ROUNDS}`;
    }

    // --- WRONG DEVICE (opened a phase link on the wrong device) ---
    function showWrongDevice(targetPhase) {
      hideBoot();
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sWrong);

      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("‚Üí");
      const targetDevice = targetPhase === 1 ? (order[0] || "phone") : (order[1] || "laptop");
      const link = handoffLink(pid, (order.join("‚Üí") || deviceOrder || ""), targetPhase);

      wrongMsg.innerHTML =
        `This link is for your <b>${targetDevice}</b> (Phase ${targetPhase}). ` +
        `You‚Äôre on a <b>${getDevice()}</b>. Please open it on the other device.`;

      wrongUrl.textContent = link;

      const showQR = (getDevice() === "laptop") && (targetDevice === "phone");
      const qrBox = wrongQr.parentElement;
      if (showQR) {
        showEl(qrBox);
        setTimeout(() => { wrongQr.src = qrFor(link); }, 0);
      } else {
        hideEl(qrBox);
        wrongQr.removeAttribute("src");
      }

      localStorage.setItem("ts_wait_phase", String(targetPhase));
      localStorage.setItem("ts_handoff_url", link);
      localStorage.setItem("ts_page", "handoff");
    }

    function stopPoll() { if (pollId) { clearInterval(pollId); pollId = null; } }

    function startHandoffPolling(waitPhase) {
      stopPoll();
      pollId = setInterval(async () => {
        if (sHandoff.classList.contains("hidden")) { stopPoll(); return; }

        const st = await getStatus(pid);
        const [first, second] = (deviceOrder || "").split("‚Üí");
        const dev = getDevice();

        // If we‚Äôre waiting for Phase 2 and this device is the Phase 2 device,
        // start as soon as Phase 1 is done.
        if (waitPhase === 2 && dev === second && st.phase1_done && !st.phase2_done) {
          stopPoll();
          phase = waitPhase;
          gotoTrialWithLoading();
          roundIdx = -1; // start Phase 2 with practice
          return;
        }

        // If everything finished elsewhere, reset this tab.
        if (st.completed) {
          stopPoll();
          cycleToNewParticipant();
        }
      }, 2000);
    }
  </script>
</body>

</html>