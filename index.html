<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Study — Minimal Prototype</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 720px; margin: 24px auto; line-height: 1.45; }
    h1 { font-size: 1.25rem; margin-bottom: 0.25rem; }
    .muted { color: #666; font-size: 0.9rem; margin-top: 0; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin: 16px 0; }
    .hidden { display: none; }
    textarea { width: 100%; min-height: 120px; font-size: 1rem; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>Typing Study — Minimal Prototype</h1>
  <p class="muted">One page, one sentence. We’ll expand after verifying the full flow.</p>

  <!-- Section 1: Consent + Start -->
  <section id="s-consent" class="card">
    <h2>Consent</h2>
    <p>This prototype records timing for a single sentence. No personal info is collected.</p>
    <label><input id="agree" type="checkbox" /> I am 18–22 or 40–55 and I consent.</label>
    <div class="row" style="margin-top: 12px;">
      <select id="ageGroup">
        <option value="">Age group…</option>
        <option>18–22</option>
        <option>40–55</option>
      </select>
      <button id="btnStart" disabled>Start</button>
    </div>
    <p id="startInfo" class="mono"></p>
  </section>

  <!-- Section 1.5: Switch Device -->
  <section id="s-switch" class="card hidden">
    <h2>Start on your other device</h2>
    <p id="switchMsg"></p>
    <p>Open this link on your other device to continue:</p>
    <p class="mono" id="continueLink"></p>
  </section>

  <!-- Section 2: Trial -->
  <section id="s-trial" class="card hidden">
    <h2>Type Exactly What You See</h2>
    <p id="sentence" class="mono"></p>
    <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
              placeholder="Type the sentence here. It will submit automatically when it matches exactly."></textarea>
    <div class="row" style="margin-top: 8px;">
      <button id="btnSubmit" disabled>Submit (auto / Enter)</button>
      <div id="timer" class="mono" style="text-align:right;">0 ms</div>
    </div>
    <p id="help" class="muted">Tip: don’t paste; type it out. Backspace is allowed.</p>
  </section>

  <!-- Section 3: Done -->
  <section id="s-done" class="card hidden">
    <h2>Done ✅</h2>
    <p>Thanks! Data sent. Your participant ID:</p>
    <p class="mono" id="pidOut"></p>
    <p class="muted">We’ll extend this to multiple sentences and the phone/laptop flow next.</p>
  </section>

  <script>
    /********** CONFIG **********/
    const ENDPOINT = "https://script.google.com/macros/s/AKfycbz5dTthOWO4crOgte-hUWlIDR4bM2LgLshVOdV-BacKt606Ob8B5dKLxLHB2BalhYG0sg/exec";
    const SECRET   = "h33iy43brfu3hf93fhb3fi3ivh3v";
    const TEST_SENTENCE = "Machine learning can analyze how fast people type under different conditions.";

    /********** ENV & HELPERS **********/
    const IS_MOBILE = /Mobi|Android/i.test(navigator.userAgent);
    const DEVICE_NOW = IS_MOBILE ? "phone" : "laptop";
    const DEVICE_OTHER = IS_MOBILE ? "laptop" : "phone";
    const uuid = () => "TS-" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const show = (el) => el.classList.remove("hidden");
    const hide = (el) => el.classList.add("hidden");
    const ms = () => performance.now();
    const parseOrder = s => (s || "").split("→"); // ["phone","laptop"]
    const makeUrl = (pid, order) => location.origin + location.pathname + "?pid=" + encodeURIComponent(pid) + (order ? "&order=" + encodeURIComponent(order) : "");

    /********** DOM **********/
    const sConsent = document.getElementById("s-consent");
    const sSwitch  = document.getElementById("s-switch");
    const sTrial   = document.getElementById("s-trial");
    const sDone    = document.getElementById("s-done");
    const agree    = document.getElementById("agree");
    const btnStart = document.getElementById("btnStart");
    const ageGroup = document.getElementById("ageGroup");
    const startInfo= document.getElementById("startInfo");
    const switchMsg= document.getElementById("switchMsg");
    const continueLink = document.getElementById("continueLink");
    const sentence = document.getElementById("sentence");
    const input    = document.getElementById("input");
    const btnSubmit= document.getElementById("btnSubmit");
    const timerEl  = document.getElementById("timer");
    const pidOut   = document.getElementById("pidOut");

    /********** STATE **********/
    let pid = null;
    let deviceOrder = null;
    let t0 = 0, lastT = 0, started = false;
    let backspaces = 0, paused500 = 0;
    let keystrokes = [];

    function updateStartBtn(){ btnStart.disabled = !(agree.checked && ageGroup.value); }
    agree.addEventListener("change", updateStartBtn);
    ageGroup.addEventListener("change", updateStartBtn);

    // If ?pid=&order= present, adopt them (handoff)
    (function adoptFromUrl(){
      const qs = new URLSearchParams(location.search);
      const pidQ = qs.get("pid");
      const orderQ = qs.get("order");
      if (pidQ) { pid = pidQ; localStorage.setItem("ts_pid", pid); }
      if (orderQ) { deviceOrder = orderQ; localStorage.setItem("ts_device_order", deviceOrder); }
    })();

    btnStart.addEventListener("click", async () => {
      // Debounce + prevent double posts
      btnStart.disabled = true;

      // PID from URL/local or new
      pid = pid || localStorage.getItem("ts_pid") || uuid();
      localStorage.setItem("ts_pid", pid);

      // Order: if not provided via URL, randomize relative to current device
      if (!deviceOrder) {
        const coin = Math.random() < 0.5;
        deviceOrder = coin ? (DEVICE_NOW + "→" + DEVICE_OTHER) : (DEVICE_OTHER + "→" + DEVICE_NOW);
        localStorage.setItem("ts_device_order", deviceOrder);
      }

      startInfo.textContent = `PID: ${pid} • Assigned order: ${deviceOrder}`;

      // Only send participant_start once per PID on this device
      const startedKey = `ts_started_${pid}`;
      if (!localStorage.getItem(startedKey)) {
        try {
          await fetch(ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "text/plain" },
            body: JSON.stringify({
              secret: SECRET,
              type: "participant_start",
              pid,
              age_group: ageGroup.value,
              device_order: deviceOrder,
              consent_version: "v1",
              start_iso: new Date().toISOString()
            })
          });
          localStorage.setItem(startedKey, "1");
        } catch(e){ console.warn("participant_start failed", e); }
      }

      // Enforce order
      const [firstDev, secondDev] = parseOrder(deviceOrder);
      if (firstDev !== DEVICE_NOW) {
        hide(sConsent); show(sSwitch);
        const url = makeUrl(pid, deviceOrder);
        switchMsg.textContent = `Your assigned order is ${deviceOrder}. Please start on your ${firstDev}.`;
        continueLink.textContent = url;
        continueLink.style.userSelect = "all";
        return;
      }

      hide(sConsent); show(sTrial);
      setupTrial();
    });

    function setupTrial() {
      // Reset state
      sentence.textContent = TEST_SENTENCE;
      input.value = "";
      input.focus();
      keystrokes = [];
      backspaces = 0;
      paused500 = 0;
      started = false; // start timer on first key
      t0 = 0;
      lastT = 0;

      // Live timer (shows 0 until first key)
      const tick = () => {
        const now = ms();
        const elapsed = started ? Math.round(now - t0) : 0;
        timerEl.textContent = `${elapsed} ms`;
        if(!sTrial.classList.contains("hidden")) requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);

      // Event hooks
      input.addEventListener("keydown", onKeydown);
      input.addEventListener("input", onInput);
      input.addEventListener("paste", e => e.preventDefault());

      // Enable submit when correct; also auto-submit on exact match
      input.addEventListener("input", () => {
        const match = (input.value === TEST_SENTENCE);
        btnSubmit.disabled = !match;
        if (match) setTimeout(() => { if (!sTrial.classList.contains("hidden")) btnSubmit.click(); }, 0);
      });

      // Allow Enter too (but auto-submit already handles it)
      btnSubmit.addEventListener("click", submitTrial, { once: true });
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") { e.preventDefault(); if (!btnSubmit.disabled) btnSubmit.click(); }
      });
    }

    function stampStartIfNeeded(){
      if (!started) {
        started = true;
        t0 = ms();
        lastT = t0;
      }
    }

    function onKeydown(e) {
      stampStartIfNeeded();
      const t = ms();
      if (t - lastT >= 500) paused500++;
      lastT = t;
      if (e.key === "Backspace") backspaces++;
      keystrokes.push({ event_seq: keystrokes.length+1, t_ms: Math.round(t - t0), event_type: "keydown", key: e.key, value_len: input.value.length, cursor_pos: input.selectionStart, is_mobile: IS_MOBILE });
    }

    function onInput(e) {
      stampStartIfNeeded();
      const t = ms();
      if (t - lastT >= 500) paused500++;
      lastT = t;
      keystrokes.push({ event_seq: keystrokes.length+1, t_ms: Math.round(t - t0), event_type: "input", key: "", value_len: input.value.length, cursor_pos: input.selectionStart, is_mobile: IS_MOBILE });
    }

    async function submitTrial() {
      // Block further typing
      input.disabled = true;
      btnSubmit.disabled = true;

      const end = ms();
      const total = started ? Math.round(end - t0) : 0;

      // Interkey stats
      const deltas = [];
      for (let i = 1; i < keystrokes.length; i++) deltas.push(keystrokes[i].t_ms - keystrokes[i-1].t_ms);
      const meanInter = deltas.length ? Math.round(deltas.reduce((a,b)=>a+b,0)/deltas.length) : 0;
      const p95Inter = deltas.length ? Math.round(deltas.slice().sort((a,b)=>a-b)[Math.floor(0.95*(deltas.length-1))]) : 0;

      const payload = {
        secret: SECRET,
        type: "trial_summary",
        pid,
        trial_id: "T1",
        device: DEVICE_NOW,
        sentence_id: "S1",
        order_in_block: 1,
        start_ms: 0,
        end_ms: total,
        total_ms: total,
        mean_interkey_ms: meanInter,
        p95_interkey_ms: p95Inter,
        pause500_count: paused500,
        backspace_count: backspaces,
        ua: navigator.userAgent,
        os: "unknown", browser: "unknown",
        screen_w: window.screen.width, screen_h: window.screen.height, dpr: window.devicePixelRatio,
        paste_attempted: false, focus_blur_count: 0,
        flags: "proto-v2"
      };

      let ok = false;
      try {
        const res = await fetch(ENDPOINT, { method: "POST", headers: { "Content-Type": "text/plain" }, body: JSON.stringify(payload) }).then(r=>r.json());
        ok = !!res?.ok;
      } catch(e){ console.error(e); }

      // Raw keystrokes
      try {
        await fetch(ENDPOINT, { method: "POST", headers: { "Content-Type": "text/plain" }, body: JSON.stringify({ secret: SECRET, type: "keystrokes_batch", pid, trial_id: "T1", events: keystrokes }) });
      } catch(e){ console.warn("keystrokes_batch failed", e); }

      // Mark participant end
      try {
        await fetch(ENDPOINT, { method: "POST", headers: { "Content-Type": "text/plain" }, body: JSON.stringify({ secret: SECRET, type: "participant_end", pid, end_iso: new Date().toISOString() }) });
      } catch(e){}

      hide(sTrial); show(sDone);
      pidOut.textContent = pid + (ok ? "" : " (send failed)");

      // Clear started guard so another session with same PID on other device can send its own start
      // (We’ll manage multi-trial flow later.)
    }
  </script>
</body>
</html>
