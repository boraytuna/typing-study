<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Study â€” Minimal Prototype</title>
  <style>
    :root {
      --muted: #666;
      --b: #ddd;
      --r: 12px
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 720px;
      margin: 24px auto;
      line-height: 1.45
    }

    h1 {
      font-size: 1.25rem;
      margin-bottom: .25rem
    }

    .muted {
      color: var(--muted);
      font-size: .92rem;
      margin: .25rem 0
    }

    .card {
      border: 1px solid var(--b);
      border-radius: var(--r);
      padding: 16px;
      margin: 16px 0
    }

    .hidden {
      display: none
    }

    textarea {
      width: 100%;
      min-height: 140px;
      font-size: 1rem
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      cursor: pointer
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .row>* {
      flex: 1
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .center {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      border: 1px solid var(--b);
      border-radius: 999px;
      padding: .25rem .6rem .25rem .35rem
    }

    .loader {
      width: 14px;
      height: 14px;
      border: 2px solid #bbb;
      border-top-color: #444;
      border-radius: 50%;
      animation: spin 1s linear infinite
    }

    @keyframes spin {
      to {
        transform: rotate(360deg)
      }
    }

    .linkbox {
      border: 1px dashed var(--b);
      border-radius: 10px;
      padding: 10px;
      margin-top: 8px;
      background: #fafafa
    }

    img.qr {
      width: 140px;
      height: 140px;
      border: 1px solid var(--b);
      border-radius: 8px;
      background: #fff
    }

    .ok {
      color: #137333
    }

    .warn {
      color: #b06000
    }

    #s-boot {
      transition: opacity 0.3s ease;
    }

    #s-boot.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <h1>Typing Study</h1>
  <p class="muted">Test your typing speed on both your laptop keyboard and mobile device.</p>

  <section id="s-consent" class="card hidden">
    <h2>Consent</h2>
    <p>
      After you give consent and choose your age group, the server will randomly assign you
      a device order â€” <b>phoneâ†’laptop</b> or <b>laptopâ†’phone</b> â€” independent of which device youâ€™re using right now.
      If this device isnâ€™t first, weâ€™ll show a link (and a QR on laptops) to open Phase 1 on your other device.
      When Phase 1 finishes, this tab will automatically load Phase 2. <br><br>
      If this device <b>is</b> the first one in your assigned order, youâ€™ll begin Phase 1 right here.
      After completing Phase 1, youâ€™ll receive a link (and QR if on a laptop) to continue Phase 2 on your other device.
      No personal information is collected.
    </p>
    <label class="center" style="gap:.6rem">
      <input id="agree" type="checkbox" /> I am 18â€“22 or 35â€“55 and I consent.
    </label>
    <div class="row" style="margin-top:12px">
      <select id="ageGroup">
        <option value="">Age groupâ€¦</option>
        <option>18â€“22</option>
        <option>35â€“55</option>
      </select>
      <button id="btnStart" disabled>Start</button>
    </div>
    <p id="startInfo" class="mono muted"></p>
  </section>

  <section id="s-boot" class="card">
    <h2>Restoring sessionâ€¦</h2>
    <p class="muted">Please wait a moment.</p>
  </section>

  <!-- Handoff card -->
  <section id="s-handoff" class="card hidden">
    <h2 id="handoffTitle"></h2>
    <p id="handoffMsg" class="muted"></p>

    <!-- QR/link row -->
    <div class="row" style="align-items: start;">
      <div class="grow">
        <code id="handoffUrl" class="mono" style="word-break: break-all;"></code>
        <div style="margin-top: 8px;">
          <!-- inside the handoff card header row -->
          <div id="copyWrap">
            <button id="btnCopy" class="btn">Copy link</button>
          </div>
        </div>
      </div>

      <!-- ðŸ‘‰ Wrap BOTH the QR image AND the caption in the same container -->
      <div id="qrWrap" class="hidden" style="text-align:center;">
        <img id="qrImg" alt="QR" style="width:140px;height:140px;display:block;margin:0 auto;" />
        <div id="qrCap" class="muted" style="margin-top:6px;">Scan this QR with your other deviceâ€™s camera.</div>
      </div>
    </div>

    <p id="waitTxt" class="muted" style="margin-top:12px;"></p>
  </section>

  <section id="s-wrong" class="card hidden">
    <h2 class="warn">Use your other device</h2>
    <p id="wrongMsg" class="muted"></p>
    <div class="linkbox">
      <div class="mono" id="wrongUrl" style="word-break:break-all"></div>
    </div>
    <div class="center" style="gap:16px;margin-top:10px">
      <img id="wrongQr" class="qr" alt="QR code" />
      <div class="muted">Open this on your other device, or scan the QR.</div>
    </div>
  </section>

  <section id="s-trial" class="card hidden">
    <h2>Type Exactly What You See</h2>
    <p id="trialHelp" class="muted"></p>
    <p id="phaseLabel" class="muted"></p>
    <p id="sentence" class="mono"></p>
    <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
      placeholder="Type the sentence here. It will submit automatically."></textarea>
    <div class="row" style="margin-top:8px">
      <div class="pill"><span id="spin" class="loader hidden"></span><span id="status" class="muted">Ready</span></div>
      <div id="timer" class="mono" style="text-align:right">0 ms</div>
    </div>
    <p class="muted">Tip: donâ€™t paste; type it out. Backspace is allowed.
      If you make a mistake, just correct it and continue typing.
      When your input matches the sentence exactly, it will submit automatically.
      If it doesn't submit, check for extra spaces or newlines at the end.
      You can refresh the page at any time to resume your progress.
    </p>
  </section>
  Â 
  <section id="s-results" class="card hidden">
    <h2 class="ok">Your Results</h2>
    <p class="muted">
      These charts compare your performance to other participants in your age group.
      Lower time is better.
    </p>

    <div class="card" style="padding:12px;margin:12px 0;">
      <h3 style="margin:0 0 8px 0;">Laptop</h3>
      <canvas id="chartLaptop" width="640" height="220"
        style="width:100%;border:1px solid #eee;border-radius:10px;"></canvas>
      <p id="sumLaptop" class="muted" style="margin:8px 0 0 0;"></p>
    </div>

    <div class="card" style="padding:12px;margin:12px 0;">
      <h3 style="margin:0 0 8px 0;">Phone</h3>
      <canvas id="chartPhone" width="640" height="220"
        style="width:100%;border:1px solid #eee;border-radius:10px;"></canvas>
      <p id="sumPhone" class="muted" style="margin:8px 0 0 0;"></p>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="btnContinue">Continue</button>
    </div>

    <p id="resultsWarn" class="muted warn hidden" style="margin-top:10px;"></p>
  </section>

  <section id="s-done" class="card hidden">
    <h2 class="ok">Done âœ…</h2>
    <p>Thanks! Data sent. Your participant ID:</p>
    <p class="mono" id="pidOut"></p>
    <p class="muted">This page will reset for the next participant automatically.</p>
  </section>

  <script>
    /*** CONFIG ***/
    const ENDPOINT = "https://script.google.com/macros/s/AKfycbz5dTthOWO4crOgte-hUWlIDR4bM2LgLshVOdV-BacKt606Ob8B5dKLxLHB2BalhYG0sg/exec";
    // Sentences: 1 practice + 3 test sentences (same on both devices)
    const SENTENCES = {
      practice: "The quick brown fox jumps over a sleepy dog in the park.",           // practice
      tests: [
        "Many people find typing on a smartphone harder than on a laptop keyboard.",  // test 1
        "Machine learning can analyze how fast people type under different conditions to improve technology accessibility.", // test 2
        "Data collected from typing tasks can reveal patterns in human performance and guide interface design."              // test 3
      ],
      ids: { practice: "P", tests: ["S1", "S2", "S3"] } // IDs youâ€™ll see in the sheet
    };

    /*** DOM ***/
    const sConsent = document.getElementById("s-consent");
    const sHandoff = document.getElementById("s-handoff");
    const sTrial = document.getElementById("s-trial");
    const sDone = document.getElementById("s-done");
    const agree = document.getElementById("agree");
    const ageGroup = document.getElementById("ageGroup");
    const btnStart = document.getElementById("btnStart");
    const startInfo = document.getElementById("startInfo");
    const handoffMsg = document.getElementById("handoffMsg");
    const handoffUrl = document.getElementById("handoffUrl");
    const btnCopy = document.getElementById("btnCopy");
    const qrImg = document.getElementById("qrImg");
    const qrWrap = document.getElementById("qrWrap");
    const sentenceEl = document.getElementById("sentence");
    const textarea = document.getElementById("input");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const spinEl = document.getElementById("spin");
    const phaseLabel = document.getElementById("phaseLabel");
    const pidOut = document.getElementById("pidOut");
    const waitTxt = document.getElementById("waitTxt");
    const sWrong = document.getElementById("s-wrong");
    const wrongMsg = document.getElementById("wrongMsg");
    const wrongUrl = document.getElementById("wrongUrl");
    const wrongQr = document.getElementById("wrongQr");
    const trialHelp = document.getElementById("trialHelp");
    const copyWrap = document.getElementById("copyWrap");
    const sBoot = document.getElementById("s-boot");
    const hideBoot = () => sBoot && sBoot.classList.add("hidden");

    const sResults = document.getElementById("s-results");
    const chartLaptop = document.getElementById("chartLaptop");
    const chartPhone = document.getElementById("chartPhone");
    const sumLaptop = document.getElementById("sumLaptop");
    const sumPhone = document.getElementById("sumPhone");
    const btnContinue = document.getElementById("btnContinue");
    const resultsWarn = document.getElementById("resultsWarn");

    /*** STATE ***/
    let pid = null, deviceOrder = null, phase = 1;
    let t0 = 0, lastT = 0, rafId = null, frozen = false;
    let keystrokes = [], backspaces = 0, paused500 = 0, submitting = false;
    let pollId = null;
    // Round control: -1 = practice, then 0,1,2 are test rounds
    let roundIdx = -1;               // start with practice
    const TOTAL_TEST_ROUNDS = 3;     // 3 recorded rounds per phase

    /*** UTIL ***/
    const q = new URLSearchParams(window.location.search);
    const ms = () => performance.now();
    const show = el => el.classList.remove("hidden");
    const hide = el => el.classList.add("hidden");
    const hideEl = (el) => el.classList.add("hidden");
    const showEl = (el) => el.classList.remove("hidden");
    const setSpin = on => spinEl.classList.toggle("hidden", !on);
    const getDevice = () => /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? "phone" : "laptop";
    const uuid = () => "TS-" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const baseURL = () => location.origin + location.pathname;
    function handoffLink(pid, order, targetPhase) { const u = new URL(baseURL()); u.searchParams.set("pid", pid); u.searchParams.set("order", order); u.searchParams.set("phase", targetPhase); return u.toString(); }
    const qrFor = url => "https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=" + encodeURIComponent(url);

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const currentDevice = isMobile ? "phone" : "laptop";
    function splitOrder(orderStr) {
      const [firstDev, secondDev] = (orderStr || "").split("â†’");
      return { firstDev, secondDev };
    }

    // --- URL helpers ------------------------------------------------------------
    function stripQueryParams(keys) {
      try {
        const url = new URL(location.href);
        keys.forEach(k => url.searchParams.delete(k));
        history.replaceState(null, "", url);
      } catch { /* noop */ }
    }

    function setQueryParam(k, v) {
      try {
        const url = new URL(location.href);
        if (v == null) url.searchParams.delete(k);
        else url.searchParams.set(k, String(v));
        history.replaceState(null, "", url);
      } catch { /* noop */ }
    }

    // ---- Session token (per PID) ----
    const TOK_KEY = "ts_token";
    const PHASE_KEY = "ts_phase";
    const ROUND_KEY = "ts_roundIdx";

    function setTok(t) { if (t) localStorage.setItem(TOK_KEY, t); }
    function getTok() { return localStorage.getItem(TOK_KEY) || ""; }
    function clearTok() { localStorage.removeItem(TOK_KEY); }

    // ---- Progress persistence (phase + roundIdx) ----
    function saveProgress() {
      localStorage.setItem(PHASE_KEY, String(phase));
      localStorage.setItem(ROUND_KEY, String(roundIdx));
    }
    function loadProgress() {
      const p = Number(localStorage.getItem(PHASE_KEY) || 0);
      const r = Number(localStorage.getItem(ROUND_KEY) || -999);
      if (p === 1 || p === 2) phase = p;
      if (r >= -1 && r <= 2) roundIdx = r; // -1 practice, 0..2 tests
    }
    function clearProgress() {
      localStorage.removeItem(PHASE_KEY);
      localStorage.removeItem(ROUND_KEY);
    }

    // ---- Facilitator reset (visit with ?reset=1) ----
    if (q.get("reset") === "1") {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      clearTok();
      // drop query params so the page reloads clean
      location.replace(location.origin + location.pathname);
    }

    /*** BACKEND ***/
    async function post(body) {
      const r = await fetch(ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "text/plain" },
        body: JSON.stringify(body)    // no secret; backend verifies pid+session_token
      });
      return r.json();
    }

    // participant_start (no token required; returns session_token)
    const participantStart = (pid, age) => post({
      type: "participant_start",
      pid,
      age_group: age || "",
      consent_version: "v1",
      start_iso: new Date().toISOString()
    });

    // status (token required)
    const getStatus = (pid) => post({
      type: "status",
      pid,
      session_token: getTok()
    });

    // trial_summary (token required)
    const trialSummary = (payload) => post({
      type: "trial_summary",
      session_token: getTok(),
      ...payload
    });

    // participant_end (token required)
    const participantEnd = (pid) => post({
      type: "participant_end",
      pid,
      session_token: getTok(),
      end_iso: new Date().toISOString()
    });

    // get_comparison_stats (token required)
    const getComparisonStats = (pid) => post({
      type: "get_comparison_stats",
      pid,
      session_token: getTok()
    });

    /*** CONSENT UI ***/
    agree.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));
    ageGroup.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));

    btnStart.addEventListener("click", async () => {
      if (btnStart.disabled) return;
      btnStart.disabled = true;
      startInfo.innerHTML = `<span class="loader"></span> contacting serverâ€¦`;

      // If weâ€™re starting from the consent page (no pid in URL), always mint a fresh PID
      pid = q.get("pid") || uuid();
      localStorage.setItem("ts_pid", pid);

      try {
        const r = await participantStart(pid, ageGroup.value);

        if (r && r.session_token) setTok(r.session_token);

        deviceOrder = r.device_order || (r.status && r.status.device_order);
        localStorage.setItem("ts_order", deviceOrder);
        startInfo.textContent = `PID: ${pid} | Order: ${deviceOrder}`;

        const dev = getDevice()
        const [first, second] = deviceOrder.split("â†’");
        const st = r.status || await getStatus(pid);

        if (st.completed) { return cycleToNewParticipant(); }

        if (!st.phase1_done && dev === first) { phase = 1; gotoTrialWithLoading(); }
        else if (st.phase1_done && !st.phase2_done && dev === second) { phase = 2; gotoTrialWithLoading(); }
        else {
          // If weâ€™re at the wrong device for Phase 1, show a Phase 1 link but wait for Phase 2.
          if (!st.phase1_done) {
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 1);
          } else {
            // Wrong device for Phase 2 (rare): just wait for Phase 2 (and link to Phase 2)
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
        }
        // If we'd hand this device off for phase 1 and there is NO pid in the URL,
        // assume it's a stale local PID and start a fresh participant.
        if (!q.get("pid") && phase === 1 && dev === first && st.phase1_done) {
          pid = uuid();
          localStorage.setItem("ts_pid", pid);
          const r2 = await participantStart(pid, ageGroup.value);

          if (r2 && r2.session_token) setTok(r2.session_token);

          deviceOrder = r2.device_order || (r2.status && r2.status.device_order);
          localStorage.setItem("ts_order", deviceOrder);
          phase = 1; gotoTrialWithLoading();
          return;
        }
      } catch (err) {
        startInfo.textContent = "Error starting. Refresh and try again.";
        btnStart.disabled = false;
      }
    });

    // --- Smart resume on refresh anywhere after Start ---
    window.addEventListener("DOMContentLoaded", async () => {
      // Show boot screen immediately (consent is hidden initially)
      // sBoot is visible by default

      const pidQ = q.get("pid");
      const orderQ = q.get("order");
      const phaseQ = Number(q.get("phase") || 0);

      const debug = q.get("debug_results") === "1";
      if (debug) {
        hideBoot();

        pid = q.get("pid") || localStorage.getItem("ts_pid") || "";
        if (!pid) { show(sConsent); return; }

        // Ensure we have a valid session token for that pid
        try {
          const r = await participantStart(pid, "");
          if (r && r.session_token) setTok(r.session_token);
        } catch { }

        await showResultsThenFinish();
        return;
      }

      // Case A: Direct phase link (other device open)
      if (pidQ && orderQ && (phaseQ === 1 || phaseQ === 2)) {
        try {
          // Persist pid/order/phase locally
          pid = pidQ;
          deviceOrder = orderQ;
          phase = phaseQ;
          localStorage.setItem("ts_pid", pid);
          localStorage.setItem("ts_order", deviceOrder);
          localStorage.setItem("ts_phase", String(phase));

          // Mint/get token idempotently (no consent needed)
          const r = await participantStart(pid, "");
          if (r && r.session_token) setTok(r.session_token);

          // Use authoritative order + status
          const ord = (r.device_order || (r.status && r.status.device_order) || deviceOrder);
          if (ord) {
            deviceOrder = ord;
            localStorage.setItem("ts_order", deviceOrder);
          }
          const st = r.status || await getStatus(pid);
          if (!st || st.ok === false) throw new Error("status failed");

          const { firstDev, secondDev } = splitOrder(deviceOrder);
          const devNow = currentDevice;

          // *** Gate the URL's phase by real server status ***
          if (phaseQ === 1) {
            if (st.phase1_done) {
              // Phase 1 already finished â†’ ignore stale ?phase=1
              stripQueryParams(["phase"]);
              if (!st.phase2_done) {
                // Route to Phase 2 or its handoff
                if (devNow === secondDev) {
                  phase = 2;
                  localStorage.setItem("ts_phase", "2");
                  localStorage.setItem("ts_page", "trial");
                  gotoTrialWithLoading();
                } else {
                  localStorage.setItem("ts_page", "handoff");
                  showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
                }
                return;
              } else {
                showDoneAndCycle();
                return;
              }
            } else {
              // Phase 1 is pending â†’ still honor ?phase=1, but only if youâ€™re on its device
              if (devNow !== firstDev) {
                localStorage.setItem("ts_page", "handoff");
                showWrongDevice(1);
                return;
              }
              localStorage.setItem("ts_page", "trial");
              phase = 1;
              gotoTrialWithLoading();
              return;
            }
          }

          if (phaseQ === 2) {
            if (st.phase2_done) {
              // Already done; ignore stale ?phase=2
              stripQueryParams(["phase"]);
              showDoneAndCycle();
              return;
            } else if (!st.phase1_done) {
              // Can't jump to Phase 2 before Phase 1; ignore ?phase=2 and route properly
              stripQueryParams(["phase"]);
              if (devNow === firstDev) {
                localStorage.setItem("ts_page", "trial");
                phase = 1;
                gotoTrialWithLoading();
              } else {
                localStorage.setItem("ts_page", "handoff");
                showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 1);
              }
              return;
            } else {
              // Phase 2 is pending
              if (devNow !== secondDev) {
                localStorage.setItem("ts_page", "handoff");
                showWrongDevice(2);
                return;
              }
              localStorage.setItem("ts_page", "trial");
              phase = 2;
              gotoTrialWithLoading();
              return;
            }
          }

          // Fallback (shouldnâ€™t happen)
          stripQueryParams(["phase"]);
        } catch (e) {
          // If something fails, drop into the smart resume fallback below
          console.warn("Direct-link bootstrap failed, falling back:", e);
        }
      }

      // Case B: Smart resume (refresh or returning in the middle)
      try {
        pid = localStorage.getItem("ts_pid") || "";
        deviceOrder = localStorage.getItem("ts_order") || "";
        const tok = getTok();

        if (!pid || !tok) {
          // No session â†’ show consent cleanly
          hideBoot();
          show(sConsent);
          return;
        }

        const st = await getStatus(pid);
        if (!st || st.ok === false) throw new Error("status failed");

        // Persist authoritative order
        if (st.device_order) {
          deviceOrder = st.device_order;
          localStorage.setItem("ts_order", deviceOrder);
        }

        if (st.completed) { showDoneAndCycle(); return; }

        const { firstDev, secondDev } = splitOrder(deviceOrder);
        const devNow = currentDevice;

        const pageLS = localStorage.getItem("ts_page");
        const roundLS = localStorage.getItem("ts_roundIdx");
        const preferTrial = (pageLS === "trial");
        if (roundLS != null) { try { roundIdx = parseInt(roundLS, 10); } catch { } }

        if (!st.phase1_done) {
          if (devNow === firstDev) {
            phase = 1;
            localStorage.setItem("ts_phase", "1");
            localStorage.setItem("ts_page", "trial");
            gotoTrialWithLoading();
          } else {
            localStorage.setItem("ts_page", "handoff");
            showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 1);
          }
          return;
        }

        // Phase 1 done
        if (!st.phase2_done) {
          if (devNow === secondDev) {
            phase = 2;
            localStorage.setItem("ts_phase", "2");
            localStorage.setItem("ts_page", "trial");
            gotoTrialWithLoading();
          } else {
            localStorage.setItem("ts_page", "handoff");
            showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
          return;
        }

        // Fallback (shouldnâ€™t happen since completed would be true)
        showDoneAndCycle();

      } catch (e) {
        console.warn("Resume failed:", e);
        hideBoot();
        show(sConsent);
      }
    });

    // --- Comparison chart drawing ---
    function fmtMs(v) {
      if (!Number.isFinite(v)) return "";
      if (v >= 10000) return (v / 1000).toFixed(1) + "s";
      return Math.round(v) + "ms";
    }

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function drawComparisonChart(canvas, payload) {
      const ctx = setupCanvasForDPR(canvas);

      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      ctx.clearRect(0, 0, w, h);
      ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "alphabetic";

      // basic empty cases
      if (!payload || payload.n == null || payload.n < 1 || payload.participant_avg_ms == null) {
        ctx.fillText("No data available.", 14, 28);
        return;
      }
      if (payload.n < 5 || payload.group_p25_ms == null || payload.group_p50_ms == null || payload.group_p75_ms == null) {
        ctx.fillText("Not enough comparison data yet.", 14, 28);
        ctx.fillText("Your average: " + fmtMs(payload.participant_avg_ms), 14, 48);
        return;
      }

      const p25 = payload.group_p25_ms;
      const p50 = payload.group_p50_ms;
      const p75 = payload.group_p75_ms;
      const you = payload.participant_avg_ms;

      // layout
      const padL = 52, padR = 18, padT = 18, padB = 34;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;
      const y0 = padT + innerH * 0.35;
      const y1 = padT + innerH * 0.65;
      const yMid = (y0 + y1) / 2;

      // x domain: centered around IQR, padded
      const iqr = Math.max(1, p75 - p25);
      const domainMin = Math.min(p25 - 0.75 * iqr, you - 0.25 * iqr);
      const domainMax = Math.max(p75 + 0.75 * iqr, you + 0.25 * iqr);
      const span = Math.max(1, domainMax - domainMin);

      const xFor = (v) => padL + ((v - domainMin) / span) * innerW;

      // frame
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.strokeRect(padL, padT, innerW, innerH);

      // axis baseline
      const yAxis = padT + innerH + 0.5;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.moveTo(padL, yAxis);
      ctx.lineTo(padL + innerW, yAxis);
      ctx.stroke();

      // ticks
      const ticks = 4;
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      for (let i = 0; i <= ticks; i++) {
        const t = i / ticks;
        const v = domainMin + t * span;
        const x = padL + t * innerW;
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.moveTo(x, yAxis);
        ctx.lineTo(x, yAxis - 6);
        ctx.stroke();

        const label = fmtMs(v);
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, clamp(x - tw / 2, 2, w - tw - 2), h - 10);
      }

      // IQR band
      const x25 = xFor(p25);
      const x75 = xFor(p75);
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.fillRect(x25, y0, x75 - x25, y1 - y0);

      // median line (stronger)
      const x50 = xFor(p50);
      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x50, y0);
      ctx.lineTo(x50, y1);
      ctx.stroke();
      ctx.lineWidth = 1;

      // labels for quartiles inside plot to avoid overlap
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("p25", x25 - 14, y0 - 6);
      ctx.fillText("median", x50 - 18, y0 - 6);
      ctx.fillText("p75", x75 - 14, y0 - 6);

      // your marker: dot + vertical guide
      const xYou = xFor(you);
      ctx.strokeStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath();
      ctx.moveTo(xYou, padT + 10);
      ctx.lineTo(xYou, y1 + 10);
      ctx.stroke();

      ctx.fillStyle = "rgba(0,0,0,0.95)";
      ctx.beginPath();
      ctx.arc(xYou, yMid, 7, 0, Math.PI * 2);
      ctx.fill();

      // "You" label near the dot
      const youLabel = "You: " + fmtMs(you);
      const lw = ctx.measureText(youLabel).width;
      const lx = clamp(xYou - lw / 2, padL + 4, padL + innerW - lw - 4);
      ctx.fillText(youLabel, lx, padT + 14);
    }

    function setupCanvasForDPR(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }

    /*** TRIAL ***/
    function gotoTrialWithLoading() {
      stopPoll();
      hide(sConsent); hide(sHandoff); show(sTrial);
      hideBoot();
      setSpin(true); statusEl.textContent = `Preparing Phase ${phase}â€¦`;
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()}`;

      localStorage.setItem("ts_page", "trial");
      localStorage.setItem("ts_phase", String(phase));
      localStorage.setItem("ts_roundIdx", String(roundIdx));      // keep updated as rounds advance

      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");

      // â¤µï¸ resume if we crashed/refreshed mid-phase
      loadProgress();
      // Ensure roundIdx is valid for this phase
      if (roundIdx < -1 || roundIdx > 2) roundIdx = -1;

      setTimeout(gotoTrial, 150);
    }

    function tick() {
      if (frozen) return;                  // stop once we submit
      const now = ms();
      const base = t0 || now;              // guard if somehow tick ran pre-start
      timerEl.textContent = `${Math.round(now - base)} ms`;
      rafId = requestAnimationFrame(tick);
    }

    function gotoTrial() {
      setSpin(false);
      statusEl.textContent = "Ready";
      saveProgress();

      // Set the sentence + labels for this round
      const s = currentSentence();
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()} â€” ${phaseRoundLabel()}`;
      trialHelp.innerHTML = s.isPractice
        ? "<span style='color:red; font-weight:bold;'>Practice:</span> type exactly what you see. When it matches, weâ€™ll move on to Round 1."
        : (roundIdx === 0 ? "Round 1/3: type the sentence exactly. It will submit automatically."
          : `Round ${s.order}/3: type the sentence exactly.`);

      // reset timers & buffers
      keystrokes = [];
      backspaces = 0;
      paused500 = 0;
      submitting = false;
      frozen = false;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      lastT = 0;
      timerEl.textContent = "0 ms"; // ensure the UI resets

      sentenceEl.textContent = s.text;
      textarea.value = "";
      textarea.disabled = false;
      textarea.focus();

      // reset timers & buffers
      keystrokes = []; backspaces = 0; paused500 = 0; submitting = false; frozen = false;
      t0 = 0; lastT = 0; if (rafId) cancelAnimationFrame(rafId);

      // start timer on first key
      const startTimerOnce = () => {
        if (!t0) { t0 = ms(); lastT = t0; tick(); }
        textarea.removeEventListener("keydown", startTimerOnce);
      };
      textarea.addEventListener("keydown", startTimerOnce, { once: true });

      textarea.onkeydown = (e) => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        if (e.key === "Backspace") backspaces++;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "keydown",
          key: e.key,
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });
      };

      textarea.oninput = () => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "input",
          key: "",
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });

        // match against current round sentence (trim trailing space/newline)
        const typed = textarea.value.replace(/\s+$/, "");
        const target = currentSentence().text.replace(/\s+$/, "");
        if (!submitting && typed === target) submitTrial();
      };

      textarea.onpaste = (e) => e.preventDefault();
    }

    /*** SUBMIT ***/
    async function submitTrial() {
      submitting = true;
      textarea.disabled = true;
      setSpin(true);
      statusEl.textContent = "Submittingâ€¦";

      // stop timer now
      frozen = true;
      if (rafId) cancelAnimationFrame(rafId);
      if (t0) timerEl.textContent = `${Math.round(ms() - t0)} ms`;

      // timing summary
      const end = ms(), total = Math.round(end - (t0 || end));
      const deltas = [];
      for (let i = 1; i < keystrokes.length; i++) deltas.push(keystrokes[i].t_ms - keystrokes[i - 1].t_ms);
      const mean = deltas.length ? Math.round(deltas.reduce((a, b) => a + b, 0) / deltas.length) : 0;
      const p95 = deltas.length ? Math.round(deltas.sort((a, b) => a - b)[Math.floor(0.95 * (deltas.length - 1))]) : 0;

      const s = currentSentence();

      // Practice trial: donâ€™t send to backendâ€”just advance to Round 1
      if (s.isPractice) {
        setSpin(false);
        statusEl.textContent = "Nice! Practice done â€” starting Round 1â€¦";
        roundIdx = 0;           // begin recorded rounds
        saveProgress();
        setTimeout(gotoTrialWithLoading, 500);
        return;
      }

      // Recorded trial â†’ send to backend
      const payload = {
        type: "trial_summary",
        pid,
        trial_id: `P${phase}-R${s.order}`,          // e.g., P1-R2
        device: getDevice(),
        sentence_id: s.id,                          // S1/S2/S3
        order_in_block: s.order,                    // 1..3 (0 was practice)
        start_ms: 0, end_ms: total, total_ms: total,
        mean_interkey_ms: mean, p95_interkey_ms: p95,
        pause500_count: paused500, backspace_count: backspaces,
        ua: navigator.userAgent, os: "unknown", browser: "unknown",
        screen_w: screen.width, screen_h: screen.height, dpr: devicePixelRatio,
        paste_attempted: false, focus_blur_count: 0, flags: "proto-v3"
      };

      try {
        const r = await trialSummary(payload);
        setSpin(false);
        if (!r.ok) throw new Error(r.error || "submit failed");

        // More recorded rounds left in this phase?
        if (roundIdx + 1 < TOTAL_TEST_ROUNDS) {
          roundIdx += 1;
          saveProgress();
          statusEl.textContent = `Saved. Starting ${roundIdx + 1 < TOTAL_TEST_ROUNDS ? `Round ${roundIdx + 1 + 1}` : "final round"}â€¦`;
          setTimeout(gotoTrialWithLoading, 500);
          return;
        }

        // Phase finished (3 recorded trials)
        // r.next already comes from backendâ€™s phase flags. Weâ€™ll still follow your handoff logic:
        if (r.next === 2) {
          const devNow = getDevice();
          statusEl.textContent = devNow === "laptop"
            ? "Phase 1 complete. Use the link/QR below to continue on your phone."
            : "Phase 1 complete. This page will help you continue on your other device.";
          roundIdx = -1; // reset so Phase 2 starts with practice again

          // Kill stale ?phase=1 from the P1 device URL so a refresh canâ€™t jump back into Phase 1.
          stripQueryParams(["phase"]);

          showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          return;
        }

        if (r.next === "done") {
          roundIdx = -1;
          clearProgress();
          await showResultsThenFinish();
          return;
        }

        // Fallback: if backend says still same phase (unlikely), start over safely
        statusEl.textContent = "Saved. Preparing next stepâ€¦";
        setTimeout(gotoTrialWithLoading, 400);

      } catch (e) {
        statusEl.textContent = "Network error â€” try again";
        textarea.disabled = false; submitting = false;
      }
    }

    // --- HANDOFF CARD (shows link/QR, polls, and auto-switches when ready) ---
    function showHandoff(currentDevice, waitPhase, linkPhase = waitPhase) {
      // NEW: this page is not a trial; remove stale ?phase=... so refresh canâ€™t resurrect old phase.
      stripQueryParams(["phase"]);
      localStorage.setItem("ts_page", "handoff");
      localStorage.removeItem("ts_roundIdx");

      hide(sConsent); hide(sTrial); hideBoot(); show(sHandoff);
      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("â†’");
      const orderStr = order.join("â†’") || (deviceOrder || "");
      const linkTargetDevice = (linkPhase === 1 ? order[0] : order[1]) || "phone";
      const link = handoffLink(pid, orderStr, linkPhase);

      localStorage.setItem("ts_page", "handoff");

      // "Preparing" only when this device is the one that will run the linked phase
      const isPreparing = (currentDevice === linkTargetDevice) && (linkPhase === waitPhase);

      const isWrongStartWithP1Link = (waitPhase === 2 && linkPhase === 1);
      const isP1JustFinishedOnLaptop =
        (currentDevice === "laptop") && (linkPhase === 2) && (linkTargetDevice === "phone");

      // Title
      const handoffTitle = document.getElementById("handoffTitle");
      handoffTitle.textContent = (linkPhase === 1) ? "Start on your other device"
        : "Continue on your other device";

      // Message
      if (isWrongStartWithP1Link) {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. After finishing Phase 1 on your <b>${order[0]}</b>, ` +
          `<b>this page</b> will automatically switch to Phase 2 on your <b>${order[1]}</b>.`;
      } else if (isP1JustFinishedOnLaptop) {
        handoffMsg.innerHTML =
          `Phase 1 on your <b>laptop</b> is done. Use the link (or QR) below to start Phase 2 on your <b>phone</b>.`;
      } else {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. Please continue on your <b>${linkTargetDevice}</b>.`;
      }

      // Waiting copy
      waitTxt.textContent = isWrongStartWithP1Link
        ? "Waiting to complete Phase 1 on your other deviceâ€¦"
        : (isPreparing ? `Preparing Phase ${waitPhase}â€¦`
          : (waitPhase === 2 ? "Waiting for Phase 2 to be readyâ€¦" : "Waitingâ€¦"));

      // Link + copy button
      // Link text (always useful when not preparing)
      handoffUrl.textContent = link;

      // Hide the copy button whenever this device is preparing to actually run the phase.
      if (isPreparing) {
        if (copyWrap) {
          copyWrap.style.display = "none";   // hide entire div
        }
        if (btnCopy) {
          btnCopy.style.display = "none";    // also hide button itself
          btnCopy.disabled = true;
        }
      } else {
        if (copyWrap) {
          copyWrap.style.display = "";       // restore normal visibility
        }
        if (btnCopy) {
          btnCopy.style.display = "";
          btnCopy.disabled = false;
          btnCopy.onclick = async () => {
            try { await navigator.clipboard.writeText(link); btnCopy.textContent = "Copied!"; }
            catch { }
            setTimeout(() => (btnCopy.textContent = "Copy link"), 1200);
          };
        }
      }

      // QR visibility
      // - only on laptop
      // - only when the link targets the phone
      // - never on "preparing" views
      const shouldShowQR =
        (currentDevice === "laptop") &&
        (linkTargetDevice === "phone") &&
        !isPreparing;

      if (shouldShowQR) {
        showEl(qrWrap);              // shows image + caption; no empty box
        setTimeout(() => { qrImg.src = qrFor(link); }, 0);
      } else {
        hideEl(qrWrap);
        qrImg.removeAttribute("src");
      }

      // Show card
      statusEl.textContent = "";
      setSpin(false);
      hideBoot();
      hide(sTrial); hide(sConsent); show(sHandoff);

      // Persist + poll for the phase weâ€™re waiting on
      localStorage.setItem("ts_wait_phase", String(waitPhase));
      localStorage.setItem("ts_handoff_url", link);
      startHandoffPolling(waitPhase);
    }

    /*** DONE + AUTO-CYCLE ***/
    function showDoneAndCycle() {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sDone);
      pidOut.textContent = pid;
      setTimeout(cycleToNewParticipant, 3000);
      stopPoll();
    }
    function cycleToNewParticipant() {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      clearProgress();
      clearTok();
      location.replace(baseURL());
    }
    function currentSentence() {
      if (roundIdx < 0) return { text: SENTENCES.practice, id: SENTENCES.ids.practice, order: 0, isPractice: true };
      return {
        text: SENTENCES.tests[roundIdx],
        id: SENTENCES.ids.tests[roundIdx],
        order: roundIdx + 1,
        isPractice: false
      };
    }

    function phaseRoundLabel() {
      if (roundIdx < 0) return "Practice";
      return `Round ${roundIdx + 1} of ${TOTAL_TEST_ROUNDS}`;
    }

    // --- WRONG DEVICE (opened a phase link on the wrong device) ---
    function showWrongDevice(targetPhase) {
      hideBoot();
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sWrong);

      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("â†’");
      const targetDevice = targetPhase === 1 ? (order[0] || "phone") : (order[1] || "laptop");
      const link = handoffLink(pid, (order.join("â†’") || deviceOrder || ""), targetPhase);

      wrongMsg.innerHTML =
        `This link is for your <b>${targetDevice}</b> (Phase ${targetPhase}). ` +
        `Youâ€™re on a <b>${getDevice()}</b>. Please open it on the other device.`;

      wrongUrl.textContent = link;

      const showQR = (getDevice() === "laptop") && (targetDevice === "phone");
      const qrBox = wrongQr.parentElement;
      if (showQR) {
        showEl(qrBox);
        setTimeout(() => { wrongQr.src = qrFor(link); }, 0);
      } else {
        hideEl(qrBox);
        wrongQr.removeAttribute("src");
      }

      localStorage.setItem("ts_wait_phase", String(targetPhase));
      localStorage.setItem("ts_handoff_url", link);
      localStorage.setItem("ts_page", "handoff");
    }

    function stopPoll() { if (pollId) { clearInterval(pollId); pollId = null; } }

    function startHandoffPolling(waitPhase) {
      stopPoll();
      pollId = setInterval(async () => {
        if (sHandoff.classList.contains("hidden")) { stopPoll(); return; }

        const st = await getStatus(pid);
        const [first, second] = (deviceOrder || "").split("â†’");
        const dev = getDevice();

        // If weâ€™re waiting for Phase 2 and this device is the Phase 2 device,
        // start as soon as Phase 1 is done.
        if (waitPhase === 2 && dev === second && st.phase1_done && !st.phase2_done) {
          stopPoll();
          phase = waitPhase;
          roundIdx = -1; // start Phase 2 with practice
          gotoTrialWithLoading();
          return;
        }

        // If everything finished elsewhere, reset this tab.
        if (st.completed) {
          stopPoll();
          cycleToNewParticipant();
        }
      }, 2000);
    }

    async function showResultsThenFinish() {
      hide(sConsent); hide(sHandoff); hide(sTrial); hide(sDone);
      show(sResults);
      hideBoot();

      resultsWarn.classList.add("hidden");
      btnContinue.disabled = true;

      const isDebug = q.get("debug_results") === "1";

      const wireContinue = () => {
        btnContinue.disabled = false;
        btnContinue.onclick = async () => {
          btnContinue.disabled = true;

          if (!isDebug) {
            try { await participantEnd(pid); } catch { }
          }

          clearProgress();
          clearTok();
          showDoneAndCycle();
        };
      };

      try {
        const r = await getComparisonStats(pid);
        if (!r || r.ok === false) throw new Error(r && r.error ? r.error : "stats failed");

        drawComparisonChart(chartLaptop, r.laptop);
        drawComparisonChart(chartPhone, r.phone);

        const lp = r.laptop || {};
        const ph = r.phone || {};

        sumLaptop.textContent = (lp.participant_avg_ms != null && lp.percentile != null)
          ? `You: ${Math.round(lp.participant_avg_ms)} ms, ${Math.round(lp.percentile)}th percentile (n=${lp.n}).`
          : (lp.participant_avg_ms != null ? `You: ${Math.round(lp.participant_avg_ms)} ms.` : "No laptop result found.");

        sumPhone.textContent = (ph.participant_avg_ms != null && ph.percentile != null)
          ? `You: ${Math.round(ph.participant_avg_ms)} ms, ${Math.round(ph.percentile)}th percentile (n=${ph.n}).`
          : (ph.participant_avg_ms != null ? `You: ${Math.round(ph.participant_avg_ms)} ms.` : "No phone result found.");

        if (isDebug) {
          resultsWarn.textContent = "Debug mode: this will not submit completion.";
          resultsWarn.classList.remove("hidden");
        }

        wireContinue();

      } catch (e) {
        resultsWarn.textContent = "Could not load comparison charts. You can still continue.";
        resultsWarn.classList.remove("hidden");

        sumLaptop.textContent = "";
        sumPhone.textContent = "";

        wireContinue();
      }
    }
  </script>
</body>

</html>