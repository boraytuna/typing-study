<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Study ‚Äî Minimal Prototype</title>
  <style>
    :root {
      --muted: #666;
      --b: #ddd;
      --r: 12px
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 720px;
      margin: 24px auto;
      line-height: 1.45
    }

    h1 {
      font-size: 1.25rem;
      margin-bottom: .25rem
    }

    .muted {
      color: var(--muted);
      font-size: .92rem;
      margin: .25rem 0
    }

    .card {
      border: 1px solid var(--b);
      border-radius: var(--r);
      padding: 16px;
      margin: 16px 0
    }

    .hidden {
      display: none
    }

    textarea {
      width: 100%;
      min-height: 140px;
      font-size: 1rem
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      cursor: pointer
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .row>* {
      flex: 1
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .center {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      border: 1px solid var(--b);
      border-radius: 999px;
      padding: .25rem .6rem .25rem .35rem
    }

    .loader {
      width: 14px;
      height: 14px;
      border: 2px solid #bbb;
      border-top-color: #444;
      border-radius: 50%;
      animation: spin 1s linear infinite
    }

    @keyframes spin {
      to {
        transform: rotate(360deg)
      }
    }

    .linkbox {
      border: 1px dashed var(--b);
      border-radius: 10px;
      padding: 10px;
      margin-top: 8px;
      background: #fafafa
    }

    img.qr {
      width: 140px;
      height: 140px;
      border: 1px solid var(--b);
      border-radius: 8px;
      background: #fff
    }

    .ok {
      color: #137333
    }

    .warn {
      color: #b06000
    }
  </style>
</head>

<body>
  <h1>Typing Study ‚Äî Minimal Prototype</h1>
  <p class="muted">Test your typing speed on both your laptop keyboard and mobile device.</p>

  <section id="s-consent" class="card">
    <h2>Consent</h2>
    <p>
  After you give consent and choose your age group, the server will randomly assign you
  a device order ‚Äî <b>phone‚Üílaptop</b> or <b>laptop‚Üíphone</b> ‚Äî independent of which device you‚Äôre using right now.
  If this device isn‚Äôt first, we‚Äôll show a link (and a QR on laptops) to open Phase 1 on your other device.
  When Phase 1 finishes, this tab will automatically load Phase 2. <br><br>
  If this device <b>is</b> the first one in your assigned order, you‚Äôll begin Phase 1 right here.
  After completing Phase 1, you‚Äôll receive a link (and QR if on a laptop) to continue Phase 2 on your other device.
  No personal information is collected.
</p>
    <label class="center" style="gap:.6rem">
      <input id="agree" type="checkbox" /> I am 18‚Äì22 or 40‚Äì55 and I consent.
    </label>
    <div class="row" style="margin-top:12px">
      <select id="ageGroup">
        <option value="">Age group‚Ä¶</option>
        <option>18‚Äì22</option>
        <option>40‚Äì55</option>
      </select>
      <button id="btnStart" disabled>Start</button>
    </div>
    <p id="startInfo" class="mono muted"></p>
  </section>

  <!-- Handoff card -->
  <section id="s-handoff" class="card hidden">
    <h2 id="handoffTitle"></h2>
    <p id="handoffMsg" class="muted"></p>

    <!-- QR/link row -->
    <div class="row" style="align-items: start;">
      <div class="grow">
        <code id="handoffUrl" class="mono" style="word-break: break-all;"></code>
        <div style="margin-top: 8px;">
          <!-- inside the handoff card header row -->
          <div id="copyWrap">
            <button id="btnCopy" class="btn">Copy link</button>
          </div>
        </div>
      </div>

      <!-- üëâ Wrap BOTH the QR image AND the caption in the same container -->
      <div id="qrWrap" class="hidden" style="text-align:center;">
        <img id="qrImg" alt="QR" style="width:140px;height:140px;display:block;margin:0 auto;" />
        <div id="qrCap" class="muted" style="margin-top:6px;">Scan this QR with your other device‚Äôs camera.</div>
      </div>
    </div>

    <p id="waitTxt" class="muted" style="margin-top:12px;"></p>
  </section>

  <section id="s-wrong" class="card hidden">
    <h2 class="warn">Use your other device</h2>
    <p id="wrongMsg" class="muted"></p>
    <div class="linkbox">
      <div class="mono" id="wrongUrl" style="word-break:break-all"></div>
    </div>
    <div class="center" style="gap:16px;margin-top:10px">
      <img id="wrongQr" class="qr" alt="QR code" />
      <div class="muted">Open this on your other device, or scan the QR.</div>
    </div>
  </section>

  <section id="s-trial" class="card hidden">
    <h2>Type Exactly What You See</h2>
    <p id="trialHelp" class="muted"></p>
    <p id="phaseLabel" class="muted"></p>
    <p id="sentence" class="mono"></p>
    <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
      placeholder="Type the sentence here. It will submit automatically."></textarea>
    <div class="row" style="margin-top:8px">
      <div class="pill"><span id="spin" class="loader hidden"></span><span id="status" class="muted">Ready</span></div>
      <div id="timer" class="mono" style="text-align:right">0 ms</div>
    </div>
    <p class="muted">Tip: don‚Äôt paste; type it out. Backspace is allowed.</p>
  </section>

  <section id="s-done" class="card hidden">
    <h2 class="ok">Done ‚úÖ</h2>
    <p>Thanks! Data sent. Your participant ID:</p>
    <p class="mono" id="pidOut"></p>
    <p class="muted">This page will reset for the next participant automatically.</p>
  </section>

  <script>
    /*** CONFIG ***/
    const ENDPOINT = "https://script.google.com/macros/s/AKfycbz5dTthOWO4crOgte-hUWlIDR4bM2LgLshVOdV-BacKt606Ob8B5dKLxLHB2BalhYG0sg/exec";
    // Sentences: 1 practice + 3 test sentences (same on both devices)
    const SENTENCES = {
      practice: "The quick brown fox jumps over a sleepy dog in the park.",           // practice
      tests: [
        "Many people find typing on a smartphone harder than on a laptop keyboard.",  // test 1
        "Machine learning can analyze how fast people type under different conditions to improve technology accessibility.", // test 2
        "Data collected from typing tasks can reveal patterns in human performance and guide interface design."              // test 3
      ],
      ids: { practice: "P", tests: ["S1", "S2", "S3"] } // IDs you‚Äôll see in the sheet
    };

    /*** DOM ***/
    const sConsent = document.getElementById("s-consent");
    const sHandoff = document.getElementById("s-handoff");
    const sTrial = document.getElementById("s-trial");
    const sDone = document.getElementById("s-done");
    const agree = document.getElementById("agree");
    const ageGroup = document.getElementById("ageGroup");
    const btnStart = document.getElementById("btnStart");
    const startInfo = document.getElementById("startInfo");
    const handoffMsg = document.getElementById("handoffMsg");
    const handoffUrl = document.getElementById("handoffUrl");
    const btnCopy = document.getElementById("btnCopy");
    const qrImg = document.getElementById("qrImg");
    const qrWrap = document.getElementById("qrWrap");
    const sentenceEl = document.getElementById("sentence");
    const textarea = document.getElementById("input");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const spinEl = document.getElementById("spin");
    const phaseLabel = document.getElementById("phaseLabel");
    const pidOut = document.getElementById("pidOut");
    const waitTxt = document.getElementById("waitTxt");
    const sWrong = document.getElementById("s-wrong");
    const wrongMsg = document.getElementById("wrongMsg");
    const wrongUrl = document.getElementById("wrongUrl");
    const wrongQr = document.getElementById("wrongQr");
    const trialHelp = document.getElementById("trialHelp");
    const copyWrap = document.getElementById("copyWrap");

    /*** STATE ***/
    let pid = null, deviceOrder = null, phase = 1;
    let t0 = 0, lastT = 0, rafId = null, frozen = false;
    let keystrokes = [], backspaces = 0, paused500 = 0, submitting = false;
    let pollId = null;
    // Round control: -1 = practice, then 0,1,2 are test rounds
    let roundIdx = -1;               // start with practice
    const TOTAL_TEST_ROUNDS = 3;     // 3 recorded rounds per phase

    /*** UTIL ***/
    const q = new URLSearchParams(location.search);
    const ms = () => performance.now();
    const show = el => el.classList.remove("hidden");
    const hide = el => el.classList.add("hidden");
    const hideEl = (el) => el.classList.add("hidden");
    const showEl = (el) => el.classList.remove("hidden");
    const setSpin = on => spinEl.classList.toggle("hidden", !on);
    const getDevice = () => /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? "phone" : "laptop";
    const uuid = () => "TS-" + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const baseURL = () => location.origin + location.pathname;
    function handoffLink(pid, order, targetPhase) { const u = new URL(baseURL()); u.searchParams.set("pid", pid); u.searchParams.set("order", order); u.searchParams.set("phase", targetPhase); return u.toString(); }
    const qrFor = url => "https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=" + encodeURIComponent(url);
    // put this right after /*** UTIL ***/ (below getDevice)
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const currentDevice = isMobile ? "phone" : "laptop";
    function splitOrder(orderStr) {
      const [firstDev, secondDev] = (orderStr || "").split("‚Üí");
      return { firstDev, secondDev };
    }

    // ---- Session token (per PID) ----
    const TOK_KEY = "ts_token";
    const PHASE_KEY = "ts_phase";
    const ROUND_KEY = "ts_round";

    function setTok(t) { if (t) localStorage.setItem(TOK_KEY, t); }
    function getTok() { return localStorage.getItem(TOK_KEY) || ""; }
    function clearTok() { localStorage.removeItem(TOK_KEY); }

    // ---- Progress persistence (phase + roundIdx) ----
    function saveProgress() {
      localStorage.setItem(PHASE_KEY, String(phase));
      localStorage.setItem(ROUND_KEY, String(roundIdx));
    }
    function loadProgress() {
      const p = Number(localStorage.getItem(PHASE_KEY) || 0);
      const r = Number(localStorage.getItem(ROUND_KEY) || -999);
      if (p === 1 || p === 2) phase = p;
      if (r >= -1 && r <= 2) roundIdx = r; // -1 practice, 0..2 tests
    }
    function clearProgress() {
      localStorage.removeItem(PHASE_KEY);
      localStorage.removeItem(ROUND_KEY);
    }

    // ---- Facilitator reset (visit with ?reset=1) ----
    if (q.get("reset") === "1") {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      // drop query params so the page reloads clean
      location.replace(location.origin + location.pathname);
    }

    /*** BACKEND ***/
    async function post(body) {
      const r = await fetch(ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "text/plain" },
        body: JSON.stringify(body)    // no secret; backend verifies pid+session_token
      });
      return r.json();
    }

    // participant_start (no token required; returns session_token)
    const participantStart = (pid, age) => post({
      type: "participant_start",
      pid,
      age_group: age || "",
      consent_version: "v1",
      start_iso: new Date().toISOString()
    });

    // status (token required)
    const getStatus = (pid) => post({
      type: "status",
      pid,
      session_token: getTok()
    });

    // trial_summary (token required)
    const trialSummary = (payload) => post({
      type: "trial_summary",
      session_token: getTok(),
      ...payload
    });

    // participant_end (token required)
    const participantEnd = (pid) => post({
      type: "participant_end",
      pid,
      session_token: getTok(),
      end_iso: new Date().toISOString()
    });

    /*** CONSENT UI ***/
    agree.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));
    ageGroup.addEventListener("change", () => btnStart.disabled = !(agree.checked && ageGroup.value));

    btnStart.addEventListener("click", async () => {
      if (btnStart.disabled) return;
      btnStart.disabled = true;
      startInfo.innerHTML = `<span class="loader"></span> contacting server‚Ä¶`;

      // If we‚Äôre starting from the consent page (no pid in URL), always mint a fresh PID
      pid = q.get("pid") || uuid();
      localStorage.setItem("ts_pid", pid);

      try {
        const r = await participantStart(pid, ageGroup.value);

        if (r && r.session_token) setTok(r.session_token);

        deviceOrder = r.device_order || (r.status && r.status.device_order);
        localStorage.setItem("ts_order", deviceOrder);
        startInfo.textContent = `PID: ${pid} | Order: ${deviceOrder}`;

        const dev = getDevice()
        const [first, second] = deviceOrder.split("‚Üí");
        const st = r.status || await getStatus(pid);

        if (st.completed) { return cycleToNewParticipant(); }

        if (!st.phase1_done && dev === first) { phase = 1; gotoTrialWithLoading(); }
        else if (st.phase1_done && !st.phase2_done && dev === second) { phase = 2; gotoTrialWithLoading(); }
        else {
          // If we‚Äôre at the wrong device for Phase 1, show a Phase 1 link but wait for Phase 2.
          if (!st.phase1_done) {
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 1);
          } else {
            // Wrong device for Phase 2 (rare): just wait for Phase 2 (and link to Phase 2)
            showHandoff(dev, /*waitPhase*/ 2, /*linkPhase*/ 2);
          }
        }
        // If we'd hand this device off for phase 1 and there is NO pid in the URL,
        // assume it's a stale local PID and start a fresh participant.
        if (!q.get("pid") && phase === 1 && dev === first && st.phase1_done) {
          pid = uuid();
          localStorage.setItem("ts_pid", pid);
          const r2 = await participantStart(pid, ageGroup.value);

          if (r2 && r2.session_token) setTok(r2.session_token);

          deviceOrder = r2.device_order || (r2.status && r2.status.device_order);
          localStorage.setItem("ts_order", deviceOrder);
          phase = 1; gotoTrialWithLoading();
          return;
        }
      } catch (err) {
        startInfo.textContent = "Error starting. Refresh and try again.";
        btnStart.disabled = false;
      }
    });

    /*** DIRECT PHASE LINKS (from QR/handoff) ***/
    window.addEventListener("DOMContentLoaded", async () => {
      const pidQ = q.get("pid"), orderQ = q.get("order"), phaseQ = Number(q.get("phase") || 0);
      // If there is NO pid in the URL, clear any stale local session
      if (!pidQ) {
        localStorage.removeItem("ts_pid");
        localStorage.removeItem("ts_order");
        localStorage.removeItem("ts_wait_phase");
        localStorage.removeItem("ts_handoff_url");
      }
      // If there IS a pid in the URL, it takes precedence over localStorage
      // (this allows reloading the handoff link without breaking)
      if (pidQ && orderQ && (phaseQ === 1 || phaseQ === 2)) {
        pid = pidQ; deviceOrder = orderQ; phase = phaseQ;
        localStorage.setItem("ts_pid", pid);
        localStorage.setItem("ts_order", deviceOrder);

        hide(sConsent); show(sHandoff); // brief state so user sees progress
        hideEl(qrWrap);          // hide QR while we‚Äôre just ‚Äúpreparing‚Ä¶‚Äù
        waitTxt.textContent = `Preparing Phase ${phase}‚Ä¶`;
        // Hide the copy UI on "preparing" views (same-device load)
        if (copyWrap) copyWrap.style.display = "none";
        if (btnCopy) { btnCopy.style.display = "none"; btnCopy.disabled = true; }

        // üîë Ensure server row exists & fetch authoritative order
        try {
          const r = await participantStart(pid, ""); // idempotent
          if (r && r.session_token) setTok(r.session_token);
          deviceOrder = r.device_order || (r.status && r.status.device_order) || deviceOrder;
          localStorage.setItem("ts_order", deviceOrder);
        } catch (e) { }

        // If wrong device, keep handoff; otherwise go into trial
        const dev = getDevice(); const [first, second] = deviceOrder.split("‚Üí");
        if ((phase === 1 && dev !== first) || (phase === 2 && dev !== second)) {
          // explicit ‚Äúwrong device‚Äù page instead of the generic handoff card
          showWrongDevice(phase);
        } else {
          gotoTrialWithLoading();
        }
        return;
      }

      // If page was refreshed while waiting, resume the handoff view
      const waitPhase = Number(localStorage.getItem("ts_wait_phase") || 0);
      const storedPid = localStorage.getItem("ts_pid");
      const storedOrd = localStorage.getItem("ts_order");
      if (!pidQ && waitPhase && storedPid && storedOrd) {
        pid = storedPid; deviceOrder = storedOrd; phase = waitPhase;
        showHandoff(getDevice(), waitPhase);
        return;
      }

      show(sConsent);
    });

    /*** TRIAL ***/
    function gotoTrialWithLoading() {
      stopPoll();
      hide(sConsent); hide(sHandoff); show(sTrial);
      setSpin(true); statusEl.textContent = `Preparing Phase ${phase}‚Ä¶`;
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()}`;

      // ‚§µÔ∏è resume if we crashed/refreshed mid-phase
      loadProgress();
      // Ensure roundIdx is valid for this phase
      if (roundIdx < -1 || roundIdx > 2) roundIdx = -1;

      setTimeout(gotoTrial, 150);
    }

    function tick() {
      if (frozen) return;                  // stop once we submit
      const now = ms();
      const base = t0 || now;              // guard if somehow tick ran pre-start
      timerEl.textContent = `${Math.round(now - base)} ms`;
      rafId = requestAnimationFrame(tick);
    }

    function gotoTrial() {
      setSpin(false);
      statusEl.textContent = "Ready";
      saveProgress();

      // Set the sentence + labels for this round
      const s = currentSentence();
      phaseLabel.textContent = `Phase ${phase} on ${getDevice()} ‚Äî ${phaseRoundLabel()}`;
      trialHelp.textContent = s.isPractice
        ? "Practice: type exactly what you see. When it matches, we‚Äôll move on to Round 1."
        : (roundIdx === 0 ? "Round 1/3: type the sentence exactly. It will submit automatically."
          : `Round ${s.order}/3: type the sentence exactly.`);

      // reset timers & buffers
      keystrokes = [];
      backspaces = 0;
      paused500 = 0;
      submitting = false;
      frozen = false;

      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      lastT = 0;
      timerEl.textContent = "0 ms"; // ensure the UI resets

      sentenceEl.textContent = s.text;
      textarea.value = "";
      textarea.disabled = false;
      textarea.focus();

      // reset timers & buffers
      keystrokes = []; backspaces = 0; paused500 = 0; submitting = false; frozen = false;
      t0 = 0; lastT = 0; if (rafId) cancelAnimationFrame(rafId);

      // start timer on first key
      const startTimerOnce = () => {
        if (!t0) { t0 = ms(); lastT = t0; tick(); }
        textarea.removeEventListener("keydown", startTimerOnce);
      };
      textarea.addEventListener("keydown", startTimerOnce, { once: true });

      textarea.onkeydown = (e) => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        if (e.key === "Backspace") backspaces++;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "keydown",
          key: e.key,
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });
      };

      textarea.oninput = () => {
        const t = ms();
        if (t0 && t - lastT >= 500) paused500++;
        lastT = t;
        keystrokes.push({
          t_ms: t0 ? Math.round(t - t0) : 0,
          event_type: "input",
          key: "",
          value_len: textarea.value.length,
          is_mobile: getDevice() === "phone"
        });

        // match against current round sentence (trim trailing space/newline)
        const typed = textarea.value.replace(/\s+$/, "");
        const target = currentSentence().text.replace(/\s+$/, "");
        if (!submitting && typed === target) submitTrial();
      };

      textarea.onpaste = (e) => e.preventDefault();
    }

    /*** SUBMIT ***/
    async function submitTrial() {
      submitting = true;
      textarea.disabled = true;
      setSpin(true);
      statusEl.textContent = "Submitting‚Ä¶";

      // stop timer now
      frozen = true;
      if (rafId) cancelAnimationFrame(rafId);
      if (t0) timerEl.textContent = `${Math.round(ms() - t0)} ms`;

      // timing summary
      const end = ms(), total = Math.round(end - (t0 || end));
      const deltas = [];
      for (let i = 1; i < keystrokes.length; i++) deltas.push(keystrokes[i].t_ms - keystrokes[i - 1].t_ms);
      const mean = deltas.length ? Math.round(deltas.reduce((a, b) => a + b, 0) / deltas.length) : 0;
      const p95 = deltas.length ? Math.round(deltas.sort((a, b) => a - b)[Math.floor(0.95 * (deltas.length - 1))]) : 0;

      const s = currentSentence();

      // Practice trial: don‚Äôt send to backend‚Äîjust advance to Round 1
      if (s.isPractice) {
        setSpin(false);
        statusEl.textContent = "Nice! Practice done ‚Äî starting Round 1‚Ä¶";
        roundIdx = 0;           // begin recorded rounds
        saveProgress();
        setTimeout(gotoTrialWithLoading, 500);
        return;
      }

      // Recorded trial ‚Üí send to backend
      const payload = {
        type: "trial_summary",
        pid,
        trial_id: `P${phase}-R${s.order}`,          // e.g., P1-R2
        device: getDevice(),
        sentence_id: s.id,                          // S1/S2/S3
        order_in_block: s.order,                    // 1..3 (0 was practice)
        start_ms: 0, end_ms: total, total_ms: total,
        mean_interkey_ms: mean, p95_interkey_ms: p95,
        pause500_count: paused500, backspace_count: backspaces,
        ua: navigator.userAgent, os: "unknown", browser: "unknown",
        screen_w: screen.width, screen_h: screen.height, dpr: devicePixelRatio,
        paste_attempted: false, focus_blur_count: 0, flags: "proto-v3"
      };

      try {
        const r = await trialSummary(payload);
        setSpin(false);
        if (!r.ok) throw new Error(r.error || "submit failed");

        // More recorded rounds left in this phase?
        if (roundIdx + 1 < TOTAL_TEST_ROUNDS) {
          roundIdx += 1;
          saveProgress();
          statusEl.textContent = `Saved. Starting ${roundIdx + 1 < TOTAL_TEST_ROUNDS ? `Round ${roundIdx + 1 + 1}` : "final round"}‚Ä¶`;
          setTimeout(gotoTrialWithLoading, 500);
          return;
        }

        // Phase finished (3 recorded trials)
        // r.next already comes from backend‚Äôs phase flags. We‚Äôll still follow your handoff logic:
        if (r.next === 2) {
          // Phase 1 just finished ‚Üí show handoff to Phase 2
          const devNow = getDevice();
          statusEl.textContent = devNow === "laptop"
            ? "Phase 1 complete. Use the link/QR below to continue on your phone."
            : "Phase 1 complete. This page will help you continue on your other device.";
          roundIdx = -1; // reset so Phase 2 starts with practice again
          saveProgress();
          showHandoff(devNow, /*waitPhase*/ 2, /*linkPhase*/ 2);
          return;
        }

        if (r.next === "done") {
          // Phase 2 finished ‚Üí close the loop
          try { await participantEnd(pid); } catch { }
          clearProgress()
          clearTok();
          showDoneAndCycle();
          return;
        }

        // Fallback: if backend says still same phase (unlikely), start over safely
        statusEl.textContent = "Saved. Preparing next step‚Ä¶";
        setTimeout(gotoTrialWithLoading, 400);

      } catch (e) {
        statusEl.textContent = "Network error ‚Äî try again";
        textarea.disabled = false; submitting = false;
      }
    }

    // --- HANDOFF CARD (shows link/QR, polls, and auto-switches when ready) ---
    function showHandoff(currentDevice, waitPhase, linkPhase = waitPhase) {
      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("‚Üí");
      const orderStr = order.join("‚Üí") || (deviceOrder || "");
      const linkTargetDevice = (linkPhase === 1 ? order[0] : order[1]) || "phone";
      const link = handoffLink(pid, orderStr, linkPhase);

      // "Preparing" only when this device is the one that will run the linked phase
      const isPreparing = (currentDevice === linkTargetDevice) && (linkPhase === waitPhase);

      const isWrongStartWithP1Link = (waitPhase === 2 && linkPhase === 1);
      const isP1JustFinishedOnLaptop =
        (currentDevice === "laptop") && (linkPhase === 2) && (linkTargetDevice === "phone");

      // Title
      const handoffTitle = document.getElementById("handoffTitle");
      handoffTitle.textContent = (linkPhase === 1) ? "Start on your other device"
        : "Continue on your other device";

      // Message
      if (isWrongStartWithP1Link) {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. After finishing Phase 1 on your <b>${order[0]}</b>, ` +
          `<b>this page</b> will automatically switch to Phase 2 on your <b>${order[1]}</b>.`;
      } else if (isP1JustFinishedOnLaptop) {
        handoffMsg.innerHTML =
          `Phase 1 on your <b>laptop</b> is done. Use the link (or QR) below to start Phase 2 on your <b>phone</b>.`;
      } else {
        handoffMsg.innerHTML =
          `Your assigned order is <b>${orderStr}</b>. Please continue on your <b>${linkTargetDevice}</b>.`;
      }

      // Waiting copy
      waitTxt.textContent = isWrongStartWithP1Link
        ? "Waiting to complete Phase 1 on your other device‚Ä¶"
        : (isPreparing ? `Preparing Phase ${waitPhase}‚Ä¶`
          : (waitPhase === 2 ? "Waiting for Phase 2 to be ready‚Ä¶" : "Waiting‚Ä¶"));

      // Link + copy button
      // Link text (always useful when not preparing)
      handoffUrl.textContent = link;

      // Hide the copy button whenever this device is preparing to actually run the phase.
      if (isPreparing) {
        if (copyWrap) {
          copyWrap.style.display = "none";   // hide entire div
        }
        if (btnCopy) {
          btnCopy.style.display = "none";    // also hide button itself
          btnCopy.disabled = true;
        }
      } else {
        if (copyWrap) {
          copyWrap.style.display = "";       // restore normal visibility
        }
        if (btnCopy) {
          btnCopy.style.display = "";
          btnCopy.disabled = false;
          btnCopy.onclick = async () => {
            try { await navigator.clipboard.writeText(link); btnCopy.textContent = "Copied!"; }
            catch { }
            setTimeout(() => (btnCopy.textContent = "Copy link"), 1200);
          };
        }
      }

      // QR visibility
      // - only on laptop
      // - only when the link targets the phone
      // - never on "preparing" views
      const shouldShowQR =
        (currentDevice === "laptop") &&
        (linkTargetDevice === "phone") &&
        !isPreparing;

      if (shouldShowQR) {
        showEl(qrWrap);              // shows image + caption; no empty box
        setTimeout(() => { qrImg.src = qrFor(link); }, 0);
      } else {
        hideEl(qrWrap);
        qrImg.removeAttribute("src");
      }

      // Show card
      statusEl.textContent = "";
      setSpin(false);
      hide(sTrial); hide(sConsent); show(sHandoff);

      // Persist + poll for the phase we‚Äôre waiting on
      localStorage.setItem("ts_wait_phase", String(waitPhase));
      localStorage.setItem("ts_handoff_url", link);
      startHandoffPolling(waitPhase);
    }

    /*** DONE + AUTO-CYCLE ***/
    function showDoneAndCycle() {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sDone);
      pidOut.textContent = pid;
      setTimeout(cycleToNewParticipant, 3000);
      stopPoll();
    }
    function cycleToNewParticipant() {
      localStorage.removeItem("ts_pid");
      localStorage.removeItem("ts_order");
      localStorage.removeItem("ts_wait_phase");
      localStorage.removeItem("ts_handoff_url");
      clearProgress();
      clearTok();
      location.replace(baseURL());
    }
    function currentSentence() {
      if (roundIdx < 0) return { text: SENTENCES.practice, id: SENTENCES.ids.practice, order: 0, isPractice: true };
      return {
        text: SENTENCES.tests[roundIdx],
        id: SENTENCES.ids.tests[roundIdx],
        order: roundIdx + 1,
        isPractice: false
      };
    }

    function phaseRoundLabel() {
      if (roundIdx < 0) return "Practice";
      return `Round ${roundIdx + 1} of ${TOTAL_TEST_ROUNDS}`;
    }

    // --- WRONG DEVICE (opened a phase link on the wrong device) ---
    function showWrongDevice(targetPhase) {
      hide(sConsent); hide(sHandoff); hide(sTrial); show(sWrong);

      const order = (deviceOrder || localStorage.getItem("ts_order") || "").split("‚Üí");
      const targetDevice = targetPhase === 1 ? (order[0] || "phone") : (order[1] || "laptop");
      const link = handoffLink(pid, (order.join("‚Üí") || deviceOrder || ""), targetPhase);

      wrongMsg.innerHTML =
        `This link is for your <b>${targetDevice}</b> (Phase ${targetPhase}). ` +
        `You‚Äôre on a <b>${getDevice()}</b>. Please open it on the other device.`;

      wrongUrl.textContent = link;

      const showQR = (getDevice() === "laptop") && (targetDevice === "phone");
      const qrBox = wrongQr.parentElement;
      if (showQR) {
        showEl(qrBox);
        setTimeout(() => { wrongQr.src = qrFor(link); }, 0);
      } else {
        hideEl(qrBox);
        wrongQr.removeAttribute("src");
      }

      localStorage.setItem("ts_wait_phase", String(targetPhase));
      localStorage.setItem("ts_handoff_url", link);
    }

    function stopPoll() { if (pollId) { clearInterval(pollId); pollId = null; } }

    function startHandoffPolling(waitPhase) {
      stopPoll();
      pollId = setInterval(async () => {
        if (sHandoff.classList.contains("hidden")) { stopPoll(); return; }

        const st = await getStatus(pid);
        const [first, second] = (deviceOrder || "").split("‚Üí");
        const dev = getDevice();

        // If we‚Äôre waiting for Phase 2 and this device is the Phase 2 device,
        // start as soon as Phase 1 is done.
        if (waitPhase === 2 && dev === second && st.phase1_done && !st.phase2_done) {
          stopPoll();
          phase = waitPhase;
          gotoTrialWithLoading();
          roundIdx = -1; // start Phase 2 with practice
          return;
        }

        // If everything finished elsewhere, reset this tab.
        if (st.completed) {
          stopPoll();
          cycleToNewParticipant();
        }
      }, 2000);
    }
  </script>
</body>

</html>
